{
    "version": "https://jsonfeed.org/version/1",
    "title": "藏器于身",
    "subtitle": "待时而动",
    "icon": "https://gality.cn/images/favicon.ico",
    "description": "安全杂记 & 日常随感",
    "home_page_url": "https://gality.cn",
    "items": [
        {
            "id": "https://gality.cn/os/03-loader/",
            "url": "https://gality.cn/os/03-loader/",
            "title": "03-Loader编写",
            "date_published": "2023-08-31T08:08:10.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第四篇文章，主要讲解了 loader 的编写。在本章中，我将会介绍 loader 的主要工作以及涉及到到的核心概念，最终我们会自己实现一个 loader 来完成 kernel 执行前的所有工作，并最终执行 kernel。</p>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: GDT, protected mode, segment register, interrupts, pipelining</em></p>\n</div>\n<h1 id=\"loader的工作\"><a class=\"anchor\" href=\"#loader的工作\">#</a> Loader 的工作</h1>\n<p>总的来说，loader 的工作为以下几项（也是 loader 到 kernel 的步骤）：</p>\n<ol>\n<li>禁用中断</li>\n<li>建立 GDT</li>\n<li>进入保护模式并刷新 cpu 管道、初始化段寄存器和栈</li>\n<li>建立 kernel 页目录（ <code>page directory</code> ）和页表（ <code>page tables</code> ）</li>\n<li>打开虚拟内存（ <code>virtual memory</code> ），进入  <code>paging</code>  模式</li>\n<li>加载  <code>kernel</code>  镜像到内存</li>\n<li>执行 <code>kernel</code>  代码，控制权转交给 <code>kernel</code></li>\n</ol>\n<h1 id=\"loader编写\"><a class=\"anchor\" href=\"#loader编写\">#</a> Loader 编写</h1>\n<h2 id=\"禁用中断\"><a class=\"anchor\" href=\"#禁用中断\">#</a> 禁用中断</h2>\n<p>禁用中断通过设置 <code>IF</code> flag 来实现，当 <code>IF</code> flag 被设置为 0 时，系统会屏蔽中断命令；禁用中断非常简单，只需要一行命令即可：</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cli</pre></td></tr></table></figure><p>如果你看了很多教程的话，可能会发现，有的教程中有这行代码，而有的没有，甚至在自己写的 loader 中不禁用中断可能也不会有什么问题，但是，这里是 “可能”，如果中断发生在实模式进入保护模式之前和之后，系统都没有问题，但在模式切换进行时发生中断就会发生异常。这个情况概率比较低，少量的验证是没法复现此问题的，所以我们最好还是加上 <code>cli</code>  命令。</p>\n<h2 id=\"建立gdt\"><a class=\"anchor\" href=\"#建立gdt\">#</a> 建立 GDT</h2>\n<details class=\"info\"><summary>什么是GDT？</summary><div>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HRFRfVHV0b3JpYWw=\">GDT</span>（ <strong>Global Descriptor Table</strong>）即全局描述符表，又叫段描述符表，本质其实就是一种专用于 <code>IA-32</code>  和 <code>x86-64</code>  体系结构的二进制数据结构，该表位于内存中，具体位置保存在 <code>GDTR</code>  寄存器中，其条目描述并规定了不同内存分区的各种特征，包括基地址、大小和访问特权如可执行、可写等。 在 Intel 的术语中，这些内存区域被称为 <code>segment</code> 。</p>\n<p>我们在上一章中提到过，CPU 通过 <code>段基地址</code>  + <code>段内偏移</code> 的方式来扩展寻址空间，类似的，在保护模式下，CPU 通过 GDT 中记录的基地址和偏移地址实现寻址，因此可以通过 GDT 中记录的段的信息来进行内存的保护（对比实模式下，所有程序都可以访问任意内存）。</p>\n</div></details>\n<h3 id=\"gdtr\"><a class=\"anchor\" href=\"#gdtr\">#</a> GDTR</h3>\n<p>根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HbG9iYWxfRGVzY3JpcHRvcl9UYWJsZQ==\">手册</span>，GDT 的地址应存储在 <code>GDTR</code>  寄存器中，这个过程通过汇编指令 <code>LGDT</code>  进行加载，参数指向 <code>GDT Descriptor</code>  结构：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/qsb20j.png\" alt=\"GDT Descriptor\" /></p>\n<ul>\n<li><strong>Size</strong>：表示 GDT 的大小，以字节为单位，实际大小值为 <code>Size+1</code> ，这是因为 <code>Size</code>  的最大值是 65535，但是 GDT 的最大值为 65536（8192 条数据）；同时，GDT 的 <code>Size</code>  不能为 0</li>\n<li><strong>Offest</strong>：GDT 的线性地址（并不是物理地址，而是分页地址）</li>\n</ul>\n<p>同时，上图中我们也可以看出 <code>LGDT</code>  命令在 32 位和 64 位下采用不同的方式载入数据， <code>Offest</code>  在 32 位下只有 4 字节长度，而在 64 位下有 8 字节。</p>\n<h3 id=\"gdt\"><a class=\"anchor\" href=\"#gdt\">#</a> GDT</h3>\n<p>GDT 中的条目占 8 字节，在内存中的形式如下：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/ug568w.png\" alt=\"GDT\" /></p>\n<p>注意，GDT 中的第一个条目 (Entry 0) 永远为空，所以段数据应从第二个条目开始存储；表中的项由段选择器（Segment Selectors）存取，段选择器通过汇编指令或中断等硬件函数加载到段寄存器中。</p>\n<p>GDT 中每一项都有一个名为 <code>Segment Descriptor</code>  复杂的结构，示意图如下：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/ir3ukr.png\" alt=\"System Segment Descriptor\" /></p>\n<ul>\n<li><strong>Base</strong>：一个 32 位值（不连续），记录了该段的起始地址</li>\n<li><strong>Limit</strong>：一个 20 位值（不连续），记录最大可寻址单元，以 1 字节为单位，或以 1 页（4 KB）为单位；因此，在 32 位下，如果选择以页为单位且 limit 设为 <code>0xFFFFF</code> ，那么该段将覆盖整个 4 GB 空间</li>\n</ul>\n<details class=\"info\"><summary>64位下的GDT</summary><div>\n<p>上述图片展示的是 32 位模式下的 GDT，而在 64 位模式下，段保护机制基本被废弃了，更多的是使用页机制，因此，服务于段机制的 GDT 表项就少很多；又由于 64 位下引入的 <code>IA-32e</code>  指令集不再兼容老旧的 8086 模式，仅有代码段 CS，数据段 DS 仍和 32 位一样使用 64 位，即 8 字节的描述符，其他的段寄存器例如：DS、ES、SS 这样的段寄存器已经不再使用了，GDT 项存在的意义就更小了。</p>\n<p>另一个导致 GDT 在 64 位下不受宠的原因是，其实从 win XP 系统开始，系统进入保护模式后 GDT 的项就没用了，一直就那么空在内存中，甚至还有从系统启动到结束就没用过的表项，不但占地方还给了黑客可趁之机，很多大神看上了这一大片有可读写可执行属性的内存，就把 Shellcode 或者全局数据区布置在这了。</p>\n</div></details>\n<ul>\n<li>\n<p><strong>Access Byte</strong>：一个 8 位值（40-47），代表了该段的访问权限字段，字段参数及含义如下：</p>\n<ul>\n<li>\n<p><strong>P:</strong> 段是否存在，存在 = 1</p>\n</li>\n<li>\n<p><strong>DPL:</strong> 描述符权限级别字段， 即该段的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9TZWN1cml0eSNSaW5ncw==\"> CPU 权级</span>. <strong>0</strong> = 最高权限（内核）, <strong>3</strong> = 最低权限（用户应用）.</p>\n</li>\n<li>\n<p><strong>S:</strong> 描述符类型字段。如果设置为 <code>0</code> ，则定义了一个系统段 (例如 TSS「 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9UYXNrX1N0YXRlX1NlZ21lbnQ=\">Task State Segment</span> 」、LDT「 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9Mb2NhbF9EZXNjcmlwdG9yX1RhYmxl\">Local Descriptor Table</span> 」)；如果设置为 <code>1</code> ，则定义一个代码段或数据段。这两种描述符的 Type 字段结构有所不同，接下来分别来说：</p>\n<div class=\"note success no-icon\">\n<p><strong>S=0</strong> 时（System Segment Descriptor）</p>\n<ul>\n<li><strong>Type</strong>：定义系统段的类型（32 位模式）\n<ul>\n<li><strong>0x1:</strong> 16-bit TSS (Available)</li>\n<li><strong>0x2:</strong> LDT</li>\n<li><strong>0x3:</strong> 16-bit TSS (Busy)</li>\n<li><strong>0x9:</strong> 32-bit TSS (Available)</li>\n<li><strong>0xB:</strong> 32-bit TSS (Busy)</li>\n</ul>\n</li>\n<li><strong>Type</strong>：定义系统段的类型（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ19tb2Rl\">Long Mode</span>）\n<ul>\n<li><strong>0x2:</strong> LDT</li>\n<li><strong>0x9:</strong> 64-bit TSS (Available)</li>\n<li><strong>0xB:</strong> 64-bit TSS (Busy)</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"note success no-icon\">\n<p><strong>S=1</strong> 时（Code/Data Segment），<strong>Type</strong> 字段会被拆分为以下字段</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/shts2l.png\" alt=\"Access Byte\" /></p>\n<ul>\n<li><strong>E</strong>：第 43 位，是否可执行位， <code>0</code>  代表该段为数据段，不可执行； <code>1</code>  代表代码段，可执行</li>\n<li><strong>DC</strong>：第 42 位，方向位 / 符合位\n<ul>\n<li>对于数据段：表示方向位。 <code>0</code>  代表段向高地址增长； <code>1</code>  代表段向低地址生长</li>\n<li>对于代码段：表示符合位。 <code>0</code>  代表只有 <code>DPL</code>  字段中指定的权限可以执行该段代码； <code>1</code>  表示该段代码的执行权限可以小于等于 <code>DPL</code></li>\n</ul>\n</li>\n<li><strong>RW</strong>：第 41 位，可读 / 可写位\n<ul>\n<li>对于代码段：表示可读位。 <code>0</code>  代表该段不允许读， <code>1\t</code> 代表可读；代码段永远没有写权限。</li>\n<li>对于数据段：表示可写位。 <code>0</code>  代表该段不可写， <code>1</code>  代表可写；数据段永远有读权限。</li>\n</ul>\n</li>\n<li><strong>A</strong>：第 40 位，访问位，最好设置为 0，CPU 会在该段被访问时自动设置它。</li>\n</ul>\n</div>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Flags</strong>：一个 4 位值（52-55 位）</p>\n<ul>\n<li><strong>G</strong>：粒度位，指示 <code>Limit</code>  的单位。 <code>0</code>  表示 <code>Limit</code>  单位为 1 字节 (字节粒度)。如果设置为 <code>1</code> ，则 <code>Limit</code>  单位为 4KB 块 (页面粒度)。</li>\n<li><strong>DB</strong>：大小位， <code>0</code>  代表定义了一个 16 位保护模式段， <code>1</code>  表示定义了一个 32 位保护模式段；一个 GDT 可以同时有 16 位和 32 位的位选择器</li>\n<li><strong>L</strong>：长模式代码标志， <code>1</code>  表示该段定义为 64 位代码段，此时 <code>DB</code>  应该设置位 <code>0</code> ； <code>0</code>  表示为其他类型段</li>\n<li><strong>A</strong>：保留位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"asm\"><a class=\"anchor\" href=\"#asm\">#</a> asm</h3>\n<p>以上就是所有有关 <code>GDT</code>  的理论知识啦，现在让我们动手写一下我们的操作系统的 <code>GDT</code>  吧！梳理一下：</p>\n<ol>\n<li><code>GDT</code>  的第一项必须为空项</li>\n<li>至少定义两个段：代码段、数据段（ <code>base</code>  和 <code>length</code>  先一样即可）</li>\n<li>获取 <code>GDT</code>  的地址</li>\n<li>创建 <code>GDT Descriptor</code>  结构用于后续填充 <code>GDTR</code></li>\n</ol>\n<details class=\"info\"><summary>32bit-gdt.asm</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token label function\">gdt_start:</span> <span class=\"token comment\">; don't remove the labels, they're needed to compute sizes and jumps</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">; the GDT starts with a null 8-byte</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    dd <span class=\"token number\">0x0</span> <span class=\"token comment\">; 4 byte</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    dd <span class=\"token number\">0x0</span> <span class=\"token comment\">; 4 byte</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">; GDT for code segment. base = 0x00000000, length = 0xfffff</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">; for flags, refer to os-dev.pdf document, page 36</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token label function\">gdt_code:</span> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    dw <span class=\"token number\">0xffff</span>    <span class=\"token comment\">; segment length, bits 0-15</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    dw <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 0-15</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    db <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 16-23</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    db <span class=\"token number\">10011010b</span> <span class=\"token comment\">; flags (8 bits)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    db <span class=\"token number\">11001111b</span> <span class=\"token comment\">; flags (4 bits) + segment length, bits 16-19</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    db <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 24-31</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">; GDT for data segment. base and length identical to code segment</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">; some flags changed, again, refer to os-dev.pdf</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token label function\">gdt_data:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    dw <span class=\"token number\">0xffff</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    dw <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    db <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    db <span class=\"token number\">10010010b</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    db <span class=\"token number\">11001111b</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    db <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token label function\">gdt_end:</span> <span class=\"token comment\">; don't remove this label</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">; GDT descriptor</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token label function\">gdt_descriptor:</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    dw gdt_end <span class=\"token operator\">-</span> gdt_start <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token comment\">; size (16 bit), always one less of its true size</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    dd gdt_start <span class=\"token comment\">; address (32 bit)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">; define some constants for later use</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>CODE_SEG equ gdt_code <span class=\"token operator\">-</span> gdt_start</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>DATA_SEG equ gdt_data <span class=\"token operator\">-</span> gdt_start</pre></td></tr></table></figure></div></details>\n<p>上面的代码中其实还隐藏了一个知识点，仔细想想也确实会有一个并不是很合逻辑的地方。我们知道在高级语言，例如 <code>C语言</code> 中，一个一个的创建变量并不能保证变量在内存中是连续存储的，除非用数组；但是我们的代码里面并没有任何的特殊数据结构的形式，那么 <code>GDT</code>  的每一项在内存中是一定在一起的吗？</p>\n<details class=\"primary\"><summary>如果是，那么这代表什么？如果不是，那么实际又是怎么实现的呢？</summary><div>\n<p>答案：<strong>一定是在一起</strong>。这是因为汇编源代码里的指令和数据部分是可以自由混杂排布的，而且最终编译出来的二进制中，它们排布顺序完全遵循源代码的排布。所以你可以任意安排你的指令和数据所处的位置，只需记得要使用各种跳转指令来控制代码运行即可。</p>\n<p>但是，整个  <code>loader</code>  的起始位置，即入口代码必须在  <code>0x9000</code>  处，因为这是和  <code>mbr</code>  约定好的跳转地址（详见<a href=\"https://gality.cn/os/02-mbr/\">上一章</a>），至于后面全部可以自由发挥和排布。</p>\n<p>其实，这个特性又是另外一个问题的答案，不知道有没有读者在看前面的代码时有这么一个疑问，为什么都要在代码结束加上 <code>jmp $</code> ，一定要加吗？</p>\n<p>当然<strong>是的</strong>，这个问题的答案同样是来源于上述特性，如果不加上 <code>jmp $</code>  来使代码进入死循环，那么代码将继续向后执行，将随机乱码理解成代码去执行，这样会导致未知错误。</p>\n</div></details>\n<h2 id=\"保护模式\"><a class=\"anchor\" href=\"#保护模式\">#</a> 保护模式</h2>\n<h3 id=\"设置gdtr\"><a class=\"anchor\" href=\"#设置gdtr\">#</a> 设置 GDTR</h3>\n<p>上一步中我们已经定义了 <code>GDT</code>  和 <code>GDT Descriptor</code>  结构，只需要使用 <code>lgdt [gdt_descriptor]</code>  命令来将 <code>GDT Descriptor</code>  的地址加载到 <code>GDTR</code>  寄存器中即可。</p>\n<h3 id=\"进入保护模式\"><a class=\"anchor\" href=\"#进入保护模式\">#</a> 进入保护模式</h3>\n<p>设置完 <code>GDT</code>  后我们就可以使 CPU 进入保护模式了，进入保护模式非常简单，只需要设置 CPU 的 <code>cr0</code>  寄存器即可。 <code>cr0</code>  寄存器是一个控制寄存器，共 32 位，每一位都对应着不同的控制能力，我们这里无需管其他位的能力，只需要关注第 0 位 PE（Protected Enable）位即可，当 <code>PE=0</code>  时，启动保护模式； <code>PE=1</code>  时，则在实模式运行。</p>\n<p>我们在对 cr0 寄存器进行操作时还必须注意需要保留其他控制位值不变，想到了什么操作？没错，就是 <code>OR</code> ，该操作可以仅将第 0 位改变成 <code>1</code> ，并保持其他位不变。</p>\n<p>还有一点需要注意的是， <code>OR</code>  操作不能直接对 <code>cr0</code>  寄存器进行操作，所以我们需要借助 <code>eax</code>  寄存器来作为桥梁，完成对 <code>cr0</code>  寄存器的赋值，代码是不是已经呼之欲出了？</p>\n<details class=\"info\"><summary>进入保护模式</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">eax</span>, <span class=\"token register variable\">cr0</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>or <span class=\"token register variable\">eax</span>, <span class=\"token number\">0x1</span> <span class=\"token comment\">; 3. set 32-bit mode bit in cr0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token register variable\">cr0</span>, <span class=\"token register variable\">eax</span></pre></td></tr></table></figure></div></details>\n<p>此时，我们就正式进入保护模式了。</p>\n<h3 id=\"刷新cpu管道\"><a class=\"anchor\" href=\"#刷新cpu管道\">#</a> 刷新 CPU 管道</h3>\n<p>为什么要刷新 CPU 管道（pipeline）呢？是因为 CPU 是以 pipeline 的方式工作的，需要执行的指令都在 pipeline 中，若两个不同指令依赖同一块数据，同时修改这块数据就可能导致危险，这种情况下，就需要刷新 CPU 管道来防止这种危险发生（这里查到的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS9qYXJnb24vcC9waXBlbGluZS1mbHVzaC5odG0jOn46dGV4dD1BJTIwaGF6YXJkJTIwY29uZGl0aW9uJTIwbWF5JTIwcHJlc2VudCxjb3JydXB0ZWQlMjBieSUyMHRoZSUyMHBpcGVsaW5pbmclMjBwcm9jZXNzLg==\">资料</span>是这样的，但是感觉稍微有一点点问题，有熟悉的师傅欢迎评论区留言呀～）。</p>\n<p>刷新 CPU 管道也非常简单，可以通过一个远跳命令实现:</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>jmp CODE_SEG:init_pm <span class=\"token comment\">; far jump by using a different segment to refresh pipeline</span></pre></td></tr></table></figure><h3 id=\"初始化段寄存器\"><a class=\"anchor\" href=\"#初始化段寄存器\">#</a> 初始化段寄存器</h3>\n<p>上一章中我们已经介绍了寄存器的默认用法及含义，这里详细介绍下段寄存器各自的用途</p>\n<div class=\"note info no-icon\">\n<p>在保护模式下，CPU 提供了段寄存器（16 位）。段寄存器存放的并不是段的基地址，而是段选择符（Segment Descriptor）的相对于 GDT 地址的偏移地址（这也是为什么我们在上一节的代码中要定义 <code>CODE_SEG</code>  和 <code>DATA_SEG</code>  的原因），这些段寄存器包括 <code>cs</code> 、 <code>ss</code> 、 <code>ds</code> 、 <code>es</code> 、 <code>fs</code> 、 <code>gs</code> 。前三个寄存器有特定用途：</p>\n<ul>\n<li><strong>cs</strong>：代码段寄存器，指向包含程序指令的段</li>\n<li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段</li>\n<li><strong>ds</strong>：数据段寄存器，指向包含静态数据或全局数据的数据段</li>\n</ul>\n<p>后三个段寄存器是通用的。</p>\n</div>\n<p><code>cs</code>  寄存器直接由 CPU 设置（想想上一章中讲的）我们无需初始化，所以我们就需要初始化其他的寄存器，至于用什么初始化，当然是我们提前定义好的 <code>DATA_SEG</code>  变量啦，有一点需要注意，段寄存器同样也不能直接进行立即数的赋值，我们需要借助 <code>ax</code> （16 位）来帮助赋值。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">[</span>bits <span class=\"token number\">32</span><span class=\"token operator\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">init_pm:</span> <span class=\"token comment\">; we are now using 32-bit instructions</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\tmov <span class=\"token register variable\">ax</span>, DATA_SEG <span class=\"token comment\">; 5. update the segment registers</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mov <span class=\"token register variable\">ds</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">ss</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">es</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    mov <span class=\"token register variable\">fs</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    mov <span class=\"token register variable\">gs</span>, <span class=\"token register variable\">ax</span></pre></td></tr></table></figure><h3 id=\"初始化栈\"><a class=\"anchor\" href=\"#初始化栈\">#</a> 初始化栈</h3>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/k0xq4i.png\" alt=\"mbr工作阶段内存布局\" /></p>\n<p>还记得上面这个图吗，我们将 <code>loader</code>  的地址设置在了 <code>0x8000</code>  后 <code>0x1000</code>  的空间内，此时 <code>0x8000</code>  前后的空间和 <code>mbr</code>  前的空间都是空着的，我们用 <code>mbr</code>  前面的空间来布置栈，就像示意图中标识的那样，将栈底设置为 <code>0x7B00</code> （栈向低地址增长），代码同样非常简单。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ebp</span>, <span class=\"token number\">0x7B00</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">esp</span>, <span class=\"token register variable\">ebp</span></pre></td></tr></table></figure>",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/02-mbr/",
            "url": "https://gality.cn/os/02-mbr/",
            "title": "02-从BIOS启动到MBR编写",
            "date_published": "2023-08-22T04:03:46.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第三篇文章，主要讲解了计算机从通电到启动操作系统前的过程。在本章中，我将会介绍引导启动中的核心概念和知识，并最终自己实现一个 MBR。</p>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: assembler, BIOS, BOOT, Real mode, interrupts, CPU registers, control structures, function calling, strings</em></p>\n</div>\n<h1 id=\"bios和boot\"><a class=\"anchor\" href=\"#bios和boot\">#</a> BIOS 和 BOOT</h1>\n<p>即使不了解计算机的人也可能对于 <code>boot</code>  和 <code>bios</code>  这两个词有所耳闻，然而即使是计算机专业的人也可能会混淆这两者的概念，这里我们先来区分一下这两个概念，以便于我们后续的展开。</p>\n<ul>\n<li><ins class=\"wavy\">BIOS</ins> 是英文 &quot;Basic Input Output System&quot; 的缩略语，直译过来后中文名称就是 &quot;基本输入输出系统&quot;。它是一组固化到计算机内主板上一个<strong> ROM 芯片</strong>上的程序，由主板的制造厂商编写代码；我们有时听到的 “刷 BIOS” 就是指将主版上的 BIOS 程序进行更换。</li>\n<li><ins class=\"wavy\">BOOT</ins> 其实是指 <code>Boot Loader</code> ，boot 本身就是 “引导” 的意思，是指一种用来引导操作系统激活的程序，广泛应用于各种系统之中。</li>\n</ul>\n<h2 id=\"对比\"><a class=\"anchor\" href=\"#对比\">#</a> 对比</h2>\n<p>BIOS 保存着计算机最重要的<strong>基本输入输出程序</strong>、<strong>系统设置信息</strong>、<strong>开机后自检程序</strong>和<strong>系统自启动程序</strong>，其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。可从 CMOS 中读写系统设置的具体信息。</p>\n<p>当按下电脑开机键的一瞬间，CPU 会先被激活去寻找 BIOS，接着 BIOS 会先在 Flash Memory 中执行，初始化计算机各种硬件并检测完整性，再执行 CMOS 中用户所喜好的设置，然后 BIOS 将自己解压缩到计算机的主存储器中。再启动引导程序 boot，然后由 boot 将操作系统加载到内存中执行。</p>\n<p>Boot 的过程其实就是由 <code>mbr</code> + <code>loader</code>  一起实现的，后面会详细讲解什么是 <code>mbr</code> ，什么是 <code>loader</code> ，耐心看下去吧～</p>\n<h1 id=\"mbr实现\"><a class=\"anchor\" href=\"#mbr实现\">#</a> MBR 实现</h1>\n<p>尽管很多教程中直接提供了 <code>mbr</code>  和 <code>loader</code>  供我们使用而无需自己编写，但是我仍推荐至少自行实现一次这两者，原因如下；</p>\n<ul>\n<li>有助于提高汇编能力，这一点在后面也至关重要。</li>\n<li>它的编写并不困难，可以借助 <code>mbr</code> +  <code>loader</code>  的编写来入门操作系统的编写。</li>\n<li>从 CPU 通电开始写起有助于建立对于计算机的全面认知，为后面的内核、可执行程序的加载，以及虚拟内存的建立做好准备。</li>\n<li>boot 阶段会初步搭建起 segment 以及虚拟内存的框架，为后续 kernel 编写打下基础</li>\n</ul>\n<p>💗真是激动人心，我们要开始编写自己的 <code>mbr</code>  了！</p>\n<h2 id=\"从通电开始\"><a class=\"anchor\" href=\"#从通电开始\">#</a> 从通电开始</h2>\n<p>一个经典的问题：<span class=\"orange\">计算机通电后是怎么就进入到了操作系统呢？</span></p>\n<p>计算机通电后，CPU 处于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlOUUlRTYlQTglQTElRTUlQkMlOEYvNzM1NDUzMQ==\">实模式</span>，在实模式下，CPU 寻址方式为：由 16 位段寄存器值 * 10H 加 16 位偏移地址来形成 20 位的寻址空间，即只有 1M 的空间是可以被 CPU 读取的，而其他空间 CPU 都无法使用，CPU 必须借助这 1M 空间内的存储的各种程序来引导操作系统启动。</p>\n<details class=\"primary\"><summary>为什么是20位寻址空间呢？</summary><div>\n<p>这与 CPU 的发展历史有关，在 CPU 早期 (8086 时期)，由于 CPU 性能有限，一共只有 20 位地址线，可寻址空间只有 1M (2<sup>20</sup> bytes)，以及 8 个 16 位的通用寄存器，和 4 个 16 位的段寄存器；16 位的物理地址只能访问 64KB (2<sup>16</sup> bytes) 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的寻址地址，访问 1 MB 的内存，必须采取一种特殊的方式。</p>\n<p>特殊方式即由 <code> 段基址 + 段内偏移</code> 的方式来将 16 位的地址扩展为 20 位，具体方式如下：</p>\n<ul>\n<li>段基址：由段寄存器提供，并将寄存器值左移 4 位，将结果作为基地址。</li>\n<li>段内偏移地址：由通用寄存器来提供 (如 EIP)</li>\n</ul>\n<p>将二者相加，得到一个 20 位的地址，覆盖 CPU 20 位的寻址空间，这里给出一个例子以便于更形象的说明：</p>\n<p>例如，段基址为 <code>0x1000</code> ，段内偏移为 <code>0x1234</code> ，则此时物理地址可以由下式计算得出：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.15999999999999992em\" columnalign=\"center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mi>x</mi><mn>1000</mn><mo>&lt;</mo><mo>&lt;</mo><mn>4</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>10000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>11234</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin {array}{c}\n\n0x1000 &lt;&lt; 4 + 0x1234 = 0x10000 + 0x1234 = 0x11234\n\n\\end {array}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2000000000000002em;vertical-align:-0.35000000000000003em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8500000000000001em;\"><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35000000000000003em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span></span></span></span></span></p>\n</div></details>\n<p>因此，这至关重要的 1MB 空间的划分是已经固定好的，每一块都有规定的用途的，被映射到不同的设备上：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/vj8uwa.png\" alt=\"实模式下1M寻址空间分配表\" /></p>\n<h2 id=\"bios的工作\"><a class=\"anchor\" href=\"#bios的工作\">#</a> BIOS 的工作</h2>\n<p>我们前面提到，CPU 通电后，将会执行 BIOS 程序，那么 BIOS 具体的工作有哪些呢？包括以下几步：</p>\n<ol>\n<li>开机后 CPU 的指令寄存器 \t <code>EIP</code>  被设置为地址  <code>0xFFFF0</code> ，这一地址指向 BIOS 固件上的代码，CPU 从这里执行开机后的第一条指令；</li>\n<li>CPU 开始执行 BIOS 上的代码，这一部分主要是硬件输入输出设备相关的检查，以及建立一个最初的中断向量表（后面会提到）；</li>\n<li>BIOS 代码最后阶段的工作，就是检查启动盘上的  <code>mbr</code>  分区，所谓 mbr 分区就是指磁盘上的第一个 512 bytes 的内容，又叫 <code>引导分区</code> ；BIOS 会对这 512 bytes 做一个检查：它的最后 2 个字节必须是特定的两个 magic number： <code>0x55</code>  和  <code>0xaa</code> ，否则它就不是一个合法的启动盘；</li>\n<li>检查通过后，BIOS 将这 512B 加载到内存  <code>0x7C00</code>  处，到 0x7E00 为止，然后指令跳转到 0x7C00 开始执行；至此 BIOS 退出舞台；</li>\n</ol>\n<p>我们可以将这个过程画成一个图，来帮助我们理解</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/a4r89b.png\" alt=\"\" /></p>\n<ul>\n<li>黄色部分是 <code>mbr</code> ，被 bios 从磁盘复制到内存中去执行</li>\n<li>粉色部分是 <code>bios</code>  代码</li>\n<li>黄色部分的两边的白色部分 (0x500 开始) 是我们可以自由使用的空间</li>\n</ul>\n<h2 id=\"mbr的工作\"><a class=\"anchor\" href=\"#mbr的工作\">#</a> mbr 的工作</h2>\n<p><code>mbr</code>  的大小被限制在了 512 bytes，这对于引导一个操作系统的重任来说有点太小了，里面根本放不下太多的数据和代码，所以 <code>mbr</code>  的工作其实只是将一个 <code>laoder</code>  加载到内存，然后跳转到 <code>loader</code>  去继续执行。</p>\n<p>我们还是用一个示意图来表示这个过程的变化和内存布局：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/k0xq4i.png\" alt=\"mbr工作阶段内存布局\" /></p>\n<p>「假设我们把 <code>loader</code>  加载到 <code>0x8000</code>  处（可以任意指定加载的位置，只需要 <code>mbr</code>  中对应起来就可以）， <code>loader</code>  大约 4KB 大小」</p>\n<p>上一节中我们说过， <code>mbr</code>  被加载到内存后，前后都有一块可供我们自由使用的空间，前面那块 (0x500 开始) 较小，大约 30KB，而后面这块 (0x7E00 开始) 就大的多了，大约有 608KB 左右的空间，我们就可以利用这块内存空间，将 <code>loader</code>  加载进内存并执行。</p>\n<h2 id=\"牛刀小试\"><a class=\"anchor\" href=\"#牛刀小试\">#</a> 牛刀小试</h2>\n<p>理论知识已经学了很多了，但是直接就开始写一个完整 <code>mbr</code>  还是有点难度的，不如我们从 <code>hello world</code>  开始。</p>\n<div class=\"note default\">\n<p>🎯编写一个 mbr，并打印 'Hello World!'</p>\n</div>\n<p>原理：通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSU5UXzEwSA==\"> 0x10H 中断</span>触发 bios 中的打印服务，向屏幕输出字符，该中断的调用规则为：</p>\n<table>\n<thead>\n<tr>\n<th>Teletype output</th>\n<th>AH=0Eh</th>\n<th>AL = Character, BH = Page Number, BL = <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQklPU19Db2xvcl9BdHRyaWJ1dGVz\">Color</span> (only in graphic mode)</th>\n<th>no return</th>\n</tr>\n</thead>\n</table>\n<p>然后我们就可以编写代码了：</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span> <span class=\"token comment\">; set tty mode</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'H'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'e'</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'l'</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>int <span class=\"token number\">0x10</span> <span class=\"token comment\">; 'l' is still on al</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'o'</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">' '</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'W'</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'o'</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'r'</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'l'</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'d'</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'!'</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>jmp <span class=\"token operator\">$</span><span class=\"token comment\">;  jump to current address = infinite loop</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>times <span class=\"token number\">510</span> <span class=\"token operator\">-</span> (<span class=\"token operator\">$</span><span class=\"token operator\">-</span><span class=\"token operator\">$</span><span class=\"token operator\">$</span>) db <span class=\"token number\">0</span> <span class=\"token comment\">; fill with 0,length = (510 - previous code)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>dw <span class=\"token number\">0xaa55</span> <span class=\"token comment\">; x86 is little-endian</span></pre></td></tr></table></figure><div class=\"note info no-icon\">\n<p>nasm 语法：</p>\n<ul>\n<li><code>$</code> ：当前行在所在段的相对位移</li>\n<li><code>$$</code> ：当前段的起始地址</li>\n<li><code>dd</code> ：即  <code>define double</code> ，定义一个 4 字节值</li>\n<li><code>dw</code> ：即 <code>define word</code> ，定义一个 2 字节值</li>\n<li><code>db</code> ：即  <code>define byte</code> ，定义一个 1 字节值</li>\n</ul>\n</div>\n<p>我们把上面的代码保存成  <code>boot_hello_world.asm</code> , 然后用 <code>nasm</code>  编译他：</p>\n<p><code>nasm -fbin boot_hello_world.asm -o boot_hello_world.bin</code></p>\n<p>然后你就可以通过 <code>xxd</code>  来查看生成的 <code>bin</code>  文件:</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/szjute.jpg\" alt=\"xxd of bin file\" /></p>\n<p>我们可以看到，结尾时 Magic Number  <code>0x55aa</code> ，前面是我们写的 asm 代码转成的机器码，中间用 0 填充，一共 <code>0x200</code>  也就是 512bytes。</p>\n<p>接着就可以用 qemu 来执行他了</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>qemu-system-x86_64 boot_hello_world.bin</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>qemu boot_hello_world.bin</pre></td></tr></table></figure><p>不出意外的话，你就会看到 <code>Hello World!</code>  了🎉</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/q8kecc.png\" alt=\"qemu with hello world\" /></p>\n<h3 id=\"problem-time\"><a class=\"anchor\" href=\"#problem-time\">#</a> Problem Time</h3>\n<ol>\n<li class=\"quiz\">\n<p>以下哪行代码可以使 <code>Hello World!</code>  以绿色字体输出：</p>\n<ul class=\"options\">\n<li><code>mov bl, 0x0a</code></li>\n<li><code>mov bh, 0x0a</code></li>\n<li><code>mov bl, 0x0c</code></li>\n<li class=\"correct\">以上都不对</li>\n</ul>\n<blockquote>\n<ul class=\"options\">\n<li>该设置只有在图形化模式下才生效</li>\n<li>需设置 bl 才能影响输出字符颜色</li>\n<li>根据手册 10 才是绿色对应的代码</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"更进一步打印信息\"><a class=\"anchor\" href=\"#更进一步打印信息\">#</a> 更进一步 (打印信息)</h2>\n<p>上面我们已经学会了打印字符，那么接下来我们尝试编写几个打印函数用于输出错误或信息，帮助我们在后面的过程中定位问题。</p>\n<h3 id=\"打印新行\"><a class=\"anchor\" href=\"#打印新行\">#</a> 打印新行</h3>\n<p>先简单一点，我们写一个打印换行符的函数 <code>print_nl()</code> ，其实就是依次打印 ascii 表特殊字符中的换行符，很简单，做一点点解释</p>\n<ul>\n<li>\n<p><code>\\r</code> ：对应 ascii 码为 13 的字符，表示回车，将当前位置移到本行头</p>\n</li>\n<li>\n<p><code>\\n</code> ：对应 ascii 码为 10 的字符，表示换行，将当前位置移动到下一行</p>\n</li>\n</ul>\n<details class=\"info\"><summary>print_nl()</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; print a new line</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">print_nl:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span> <span class=\"token comment\">; tty mode</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token number\">0x0a</span> <span class=\"token comment\">; '\\r'</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token number\">0x0d</span> <span class=\"token comment\">; '\\n'</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    ret</pre></td></tr></table></figure></div></details>\n<h3 id=\"打印字符串\"><a class=\"anchor\" href=\"#打印字符串\">#</a> 打印字符串</h3>\n<p>然后加大一点难度，通过循环来实现一个打印字符串的函数 <code>print()</code> ，本质就是一个一个的打印字符，一些要点如下：</p>\n<ul>\n<li>因为调用 <code>print()</code>  的场景是程序运行过程中，所以函数开始要 <code>pusha</code>  保存 “现场”，在调用结束前还需要用 <code>popa</code>  还原 “现场”</li>\n<li>通过 <code>bx</code>  寄存器来传递参数 (寄存器有<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL2Fzc2VtYmx5X3Byb2dyYW1taW5nL2Fzc2VtYmx5X3JlZ2lzdGVycy5odG0=\">默认的用法</span>，这里推荐用 <code>bx</code>  来传递参数)</li>\n<li>可以通过 <code>cmp</code>  和 <code>je</code>  命令来进行条件判断和分支跳转。</li>\n</ul>\n<details class=\"info\"><summary>print( [bx]string s )</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; print a string pointed with bx</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">print:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">; keep this in mind:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">; while (string[i] != 0) &#123; print string[i]; i++ &#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">; the comparison for string end (null byte)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token label function\">print_start:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token operator\">[</span><span class=\"token register variable\">bx</span><span class=\"token operator\">]</span> <span class=\"token comment\">; 'bx' is the base address for the string</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; if '\\0', then stop loop</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    je print_end</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">; the part where we print with the BIOS help</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    int <span class=\"token number\">0x10</span> <span class=\"token comment\">; 'al' already contains the char</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">; increment pointer and do next loop</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    add <span class=\"token register variable\">bx</span>, <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    jmp print_start</pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token label function\">print_end:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    ret</pre></td></tr></table></figure></div></details>\n<h3 id=\"以十六进制打印数字\"><a class=\"anchor\" href=\"#以十六进制打印数字\">#</a> 以十六进制打印数字</h3>\n<p>同样的道理，我们来将数字以 16 进制打印出来，由于我们直接是直接对接底层 CPU 的处理，没有现成的进制转换函数供我们使用，此时我们需要自己处理进制转换（数字到字符）和格式化输出，步骤如下：</p>\n<ol>\n<li>参数：通过 <code>dx</code>  寄存器来传递参数</li>\n<li>预处理：用寄存器来记录需要被转换的值，寄存器为 16 位，每次处理 4 位（一个 16 进制字符），所以要建立一个循环 4 次的函数</li>\n<li>取数字：可以通过和 <code>0x000f</code>  进行 <code>与操作</code> 的方式，来仅取出 4 位数，方便后续处理</li>\n<li>进制转换：原数字 + <code>0x30</code>  就会转换成对应的数字的字符，与 9 做比较，如果更大，就加 7（对应 ascii 表的 <code>A</code> -&gt; <code>F</code> ）</li>\n<li>格式化处理：结合索引，通过移位的方式来将字符放在合适的位置，</li>\n<li>打印：调用上面写的 <code>print()</code>  函数</li>\n</ol>\n<p><span class=\"wavy\">注意</span>：字符串在定义时末尾必须加上 <code>0</code> ，来作为字符串结束的标识（例如 <code>HEX_OUT</code> ）</p>\n<details class=\"info\"><summary>print_hex( [dx]number n )</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; receiving the data in 'dx'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">; For the examples we'll assume that we're called with dx=0x1234</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token label function\">print_hex:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">cx</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; our index variable</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">; Strategy: get the last char of 'dx', then convert to ASCII</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">; Numeric ASCII values: '0' (ASCII 0x30) to '9' (0x39), so just add 0x30 to byte N.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">; For alphabetic characters A-F: 'A' (ASCII 0x41) to 'F' (0x46) we'll add 0x40</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">; Then, move the ASCII byte to the correct position on the resulting string  </span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token label function\">print_hex_start:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    cmp <span class=\"token register variable\">cx</span>, <span class=\"token number\">4</span> <span class=\"token comment\">; loop 4 times</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    je print_hex_end</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">; 1. convert last char of 'dx' to ascii</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    mov <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">dx</span> <span class=\"token comment\">; we will use 'ax' as our working register</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    and <span class=\"token register variable\">ax</span>, <span class=\"token number\">0x000f</span> <span class=\"token comment\">; 0x1234 -> 0x0004 by masking first three to zeros</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    add <span class=\"token register variable\">al</span>, <span class=\"token number\">0x30</span> <span class=\"token comment\">; add 0x30 to N to convert it to ASCII \"N\"</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token number\">0x39</span> <span class=\"token comment\">; if > 9, add extra 8 to represent 'A' to 'F'</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    jle step2</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    add <span class=\"token register variable\">al</span>, <span class=\"token number\">0x07</span> <span class=\"token comment\">; 'A' is ASCII 65 instead of 58, so 65-58=7</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token label function\">step2:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">; 2. get the correct position of the string to place our ASCII char</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">; bx &lt;- base address + string length - index of char</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, hex_string <span class=\"token operator\">+</span> <span class=\"token number\">5</span> <span class=\"token comment\">; base + length</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    sub <span class=\"token register variable\">bx</span>, <span class=\"token register variable\">cx</span> <span class=\"token comment\">; our index variable</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    mov <span class=\"token operator\">[</span><span class=\"token register variable\">bx</span><span class=\"token operator\">]</span>, <span class=\"token register variable\">al</span> <span class=\"token comment\">; copy the ASCII char on 'al' to the position pointed by 'bx'</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    ror <span class=\"token register variable\">dx</span>, <span class=\"token number\">4</span> <span class=\"token comment\">; 0x1234 -> 0x4123 -> 0x3412 -> 0x2341 -> 0x1234</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">; increment index and loop</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    add <span class=\"token register variable\">cx</span>, <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    jmp print_hex_start</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token label function\">print_hex_end:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token comment\">; prepare the parameter and call the function</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token comment\">; remember that print receives parameters in 'bx'</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, hex_string</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    ret</pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token label function\">hex_string:</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    db <span class=\"token string\">'0x0000'</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; reserve memory for our new string</span></pre></td></tr></table></figure></div></details>\n<p>完成以上打印函数后，我们可以将他们保存在 <code>print.nasm</code>  中，然后通过 <code>%include &quot;boot_print.asm&quot;</code>  的方式在别的 <code>asm</code>  中使用我们定义好的打印函数</p>\n<h2 id=\"一步登天\"><a class=\"anchor\" href=\"#一步登天\">#</a> 一步登天</h2>\n<p><s class=\"danger\">好了，现在你已经学会 1+1 了，现在请计算 9.121*7.32/6.97 吧</s></p>\n<p>根据我们之前说的，仔细想想，编写的 <code>mbr\t</code> 的功能，拆解一下其实并不复杂，本质就是读取一块硬盘，并将 <code>loader</code>  加载到内存中，然后跳转到 <code>loader</code>  执行就可以了，稍微复杂的点在于，由于历史原因，读磁盘时采用的是 CHS 的模式，这点也你会在后面更近一步学习，接着往下看吧。</p>\n<p>「以下代码的部分希望读者能自己根据原理完成，如果觉得较为困难，可以打开折叠栏查看」</p>\n<h3 id=\"nasm读硬盘\"><a class=\"anchor\" href=\"#nasm读硬盘\">#</a> nasm 读硬盘</h3>\n<p>好消息是我们无需去直接跟磁盘打交道，bios 中同样写好了读写磁盘的程序，我们只需要跟打印程序一样通过中断来调用即可。我么可以通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFuaXNsYXZzLm9yZy9oZWxwcGMvaW50XzEzLTIuaHRtbA==\"> 0x13H 中断</span>来读写磁盘，该中断的调用参数为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AH</td>\n<td style=\"text-align:center\">02H =&gt; bios 磁盘服务程序中的读磁盘程序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">要读的扇区个数\t(1-128 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CH</td>\n<td style=\"text-align:center\">磁道号的低 8 位  (0-1023 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CL</td>\n<td style=\"text-align:center\">低 5 位为所读起始扇区号， 6-7 位表示磁道号的高 2 位 (1-17 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DH</td>\n<td style=\"text-align:center\">所读磁盘的磁头号  (0-15 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DL</td>\n<td style=\"text-align:center\">需要进行读操作的驱动器号 (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ES:BX</td>\n<td style=\"text-align:center\">缓冲区地址</td>\n</tr>\n</tbody>\n</table>\n<p>返回值为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AH</td>\n<td style=\"text-align:center\">status  (see INT 13,STATUS)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">number of sectors read</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CF</td>\n<td style=\"text-align:center\">0 = successful OR 1 = error</td>\n</tr>\n</tbody>\n</table>\n<p>在 mbr 启动的时候，CPU 处于实模式，此时只能使用 bios 按 CHS 的寻址方式来找到 <code>loader</code>  的位置。</p>\n<details class=\"primary\"><summary>CHS到底是什么呢？</summary><div>\n<p>CHS 即 (Cylinder/Head/Sector)，是非常古老的硬盘参数了，很久以前，硬盘的容量还很小，人们采用类似软盘的结构生产硬盘，即硬盘盘片的每一条磁道都具有相同的扇区数，由此产生了磁头数 (Heads)，柱面数 (Cylinders)，扇区数 (Sectors) 以及相应的寻址方式.</p>\n<p>其中:</p>\n<ul>\n<li>磁头数 (Heads)：表示硬盘总共有几个磁头，也就是有几面盘片，最大为 255  (用 8 个二进制位存储);</li>\n<li>柱面数 (Cylinders)：表示硬盘每一面盘片上有几条磁道，最大为 1023 (用 10 个二进制位存储) =&gt; 每条磁道都有编号，叫做磁道号；</li>\n<li>扇区数 (Sectors)：表示每一条磁道上有几个扇区，最大为  63  (用 6  个二进制位存储).</li>\n</ul>\n<p>每个扇区一般是  512 个字节，理论上讲这不是必须的，但好象没有取别的值的。</p>\n<p>因此，数据寻址方式为：先找到磁头，然后再通过柱面和扇区来确定唯一一个磁道，磁道中记录了数据。（如果你想了解<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3lsaW5kZXItaGVhZC1zZWN0b3I=\">更多有关早期硬盘的知识</span>）</p>\n</div></details>\n<h4 id=\"参数值讲解\"><a class=\"anchor\" href=\"#参数值讲解\">#</a> 参数值讲解</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n<th style=\"text-align:center\">Remark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">0x02</td>\n<td style=\"text-align:center\">要读两个扇区 (根据实际情况)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CH</td>\n<td style=\"text-align:center\">0x0</td>\n<td style=\"text-align:center\">仍然是 0 号磁道，只不过是去读第二个扇区)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CL</td>\n<td style=\"text-align:center\">0x02</td>\n<td style=\"text-align:center\"><code>mbr</code>  总是在 <code>fisrt of cylinder 0 of head 0 of hdd 0 </code> ，因此任何字节都只能在第二个扇区之后</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DH</td>\n<td style=\"text-align:center\">0x00</td>\n<td style=\"text-align:center\">读取第一个磁头 (即第一个盘片)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DL</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">由 bios 自动设置</td>\n</tr>\n</tbody>\n</table>\n<p>我们这里先将读磁盘内容的命令封装成一个函数，同时增加一点错误输出函数来帮助我们定位可能存在的错误</p>\n<details class=\"info\"><summary>disk_load([dh]sector n)</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; load 'dh' sectors from drive 'dl' into ES:BX</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">disk_load:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\tpusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\tpush <span class=\"token register variable\">dx</span> <span class=\"token comment\">; store the argument in 'dh'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\tmov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x02</span> <span class=\"token comment\">; 0x02 = 'read disk'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\tmov <span class=\"token register variable\">al</span>, <span class=\"token register variable\">dh</span> <span class=\"token comment\">; al &lt;- number of sectors to read (0x01 .. 0x80)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\tmov <span class=\"token register variable\">cl</span>, <span class=\"token number\">0x02</span> <span class=\"token comment\">; cl &lt;- sector (0x01 .. 0x11)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\tmov <span class=\"token register variable\">ch</span>, <span class=\"token number\">0x00</span> <span class=\"token comment\">; ch &lt;- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\tmov <span class=\"token register variable\">dh</span>, <span class=\"token number\">0x00</span> <span class=\"token comment\">; dh &lt;- head number (0x0 .. 0xF)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token comment\">; [es:bx] &lt;- pointer to buffer where the data will be stored</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">; caller sets it up for us, and it is actually the standard location for int 13h</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    int <span class=\"token number\">0x13</span>      <span class=\"token comment\">; BIOS interrupt</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    jc disk_error <span class=\"token comment\">; if error (stored in the carry bit)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    pop <span class=\"token register variable\">dx</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token register variable\">dh</span>    <span class=\"token comment\">; BIOS also sets 'al' to the # of sectors read. Compare it.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    jne sectors_error</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    ret</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token label function\">disk_error:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, DISK_ERROR</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    mov <span class=\"token register variable\">dh</span>, <span class=\"token register variable\">ah</span> <span class=\"token comment\">; ah = error code, dl = disk drive that dropped the error</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    call print_hex <span class=\"token comment\">; check out the code at http://stanislavs.org/helppc/int_13-1.html</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    jmp disk_loop</pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token label function\">sectors_error:</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, SECTORS_ERROR</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token label function\">disk_loop:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    jmp <span class=\"token operator\">$</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token label function\">DISK_ERROR:</span> db <span class=\"token string\">\"Disk read error\"</span>, <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token label function\">SECTORS_ERROR:</span> db <span class=\"token string\">\"Incorrect number of sectors read\"</span>, <span class=\"token number\">0</span></pre></td></tr></table></figure></div></details>\n<p>此时还没有结束，让我们写一个 <code>main</code>  函数在将所有之前写的功能串联起来吧，注意这里还有如下几点需要注意：</p>\n<ul>\n<li>开头要加上 <code>[org 0x7c00]</code> ，该命令会将后续出现的所有地址在寻址时加上该偏移，因为这里才是 <code>mbr</code>  真实执行的地址，也即我们各种数据储存的 “基地址”，如果不加的话，在寻址时会出现错误。</li>\n<li>在安全的位置设置我们自己的堆栈</li>\n<li>记得要设置 <code>bx</code>  寄存器指向 <code>loader</code>  的加载地址（因为 <code>es:bx</code>  指向读取出的硬盘数据的存储位置）</li>\n<li>由于我们还没有写 <code>loader</code> ，可以暂时先将 <code>sector 2</code>  设置成某特殊字符，来检验读取效果</li>\n</ul>\n<details class=\"info\"><summary>main.asm</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">[</span>org <span class=\"token number\">0x7c00</span><span class=\"token operator\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    mov <span class=\"token register variable\">bp</span>, <span class=\"token number\">0x8000</span> <span class=\"token comment\">; set the stack safely away from us</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    mov <span class=\"token register variable\">sp</span>, <span class=\"token register variable\">bp</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, <span class=\"token number\">0x9000</span> <span class=\"token comment\">; es:bx = 0x0000:0x9000 = 0x09000</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">dh</span>, <span class=\"token number\">2</span> <span class=\"token comment\">; read 2 sectors</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">; the bios sets 'dl' for our boot disk number</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">; if you have trouble, use the '-fda' flag: 'qemu -fda file.bin'</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    call disk_load</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    mov <span class=\"token register variable\">dx</span>, <span class=\"token operator\">[</span><span class=\"token number\">0x9000</span><span class=\"token operator\">]</span> <span class=\"token comment\">; retrieve the first loaded word, 0xdada</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    mov <span class=\"token register variable\">dx</span>, <span class=\"token operator\">[</span><span class=\"token number\">0x9000</span> <span class=\"token operator\">+</span> <span class=\"token number\">512</span><span class=\"token operator\">]</span> <span class=\"token comment\">; first word from second loaded sector, 0xface</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    jmp <span class=\"token operator\">$</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token operator\">%</span>include <span class=\"token string\">\"boot_print.asm\"</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token operator\">%</span>include <span class=\"token string\">\"boot_sect_disk.asm\"</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">; Magic number</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>times <span class=\"token number\">510</span> <span class=\"token operator\">-</span> (<span class=\"token operator\">$</span><span class=\"token operator\">-</span><span class=\"token operator\">$</span><span class=\"token operator\">$</span>) db <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>dw <span class=\"token number\">0xaa55</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">; boot sector = sector 1 of cyl 0 of head 0 of hdd 0</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">; from now on = sector 2 ...</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>times <span class=\"token number\">256</span> dw <span class=\"token number\">0xdada</span> <span class=\"token comment\">; sector 2 = 512 bytes</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>times <span class=\"token number\">256</span> dw <span class=\"token number\">0xface</span> <span class=\"token comment\">; sector 3 = 512 bytes</span></pre></td></tr></table></figure></div></details>\n<p>🎉以上就是本章的全部内容，下一章将会继续讲解 <code>loader</code>  的实现～</p>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/01-environment/",
            "url": "https://gality.cn/os/01-environment/",
            "title": "01-环境准备",
            "date_published": "2023-08-21T02:26:23.000Z",
            "content_html": "<div class=\"note info no-icon\">\n<p>本文章中的所有实践均推荐在 Linux 环境下进行，原因在于 Linux 可以自动处理依赖关系，便捷的完成依赖工具的构建，由于博主主力电脑为 Mac，所以实践环境为 MacOS，但是大体与 Linux 没有区别，以下为默认使用的环境：</p>\n<ul>\n<li>macOS Ventura 13.4.1 (c) - 英特尔芯片</li>\n<li>qemu  8.0.4</li>\n<li>nasm 2.16.01</li>\n</ul>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: linux, mac, terminal, compiler, emulator, nasm, qemu</em></p>\n</div>\n<h1 id=\"qemu\"><a class=\"anchor\" href=\"#qemu\">#</a> QEMU</h1>\n<p><ins class=\"wavy\">QEMU</ins>(<strong>Q</strong>uick <strong>Emu</strong>lator) 是一款免费且开源的模拟器，他通过动态二进制转换来模拟 CPU，并且提供了一组硬件和设备模型，使他能够运行多种原始操作系统；它还可以通过与 KVM 交互来以接近原生的速度运行虚拟机器。QEMU 同样可以模拟用户态进程，允许应用编译为另外一种架构的应用去运行（<s>人话版本：qemu 就是一个硬件模拟器，用来模拟计算机硬件</s>）。</p>\n<p>许多从零开始写操作系统的教程均是采用 Bochs 来作为模拟器，qemu 与其相比来说，不仅更加快速，而且提供了更多的调试手段，更加灵活，所以我们选择 qemu 来做硬件模拟。</p>\n<h2 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h2>\n<p>linux 系统下可以方便的安装 qemu，而 mac 则需要通过 <code>homebrew</code>  进行安装</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brew <span class=\"token function\">install</span> qemu</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> qemu</pre></td></tr></table></figure><p>对于 linux 来说，qemu 是以一个整体存在的，也直接通过 <code>qemu</code>  命令运行 <code>qemu</code> ，而对于 mac 来说，qemu 会被拆分为多个部分，可以通过补全来看到所有部分：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/4c7nqq.png\" alt=\"\" /></p>\n<p>当安装完成后，我们可以通过 <code>qemu-system-x86_64</code>  来运行一个 qemu 虚拟机，如果此时你看到了这样一个黑框，那么恭喜你，qemu 就安装完成了。</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/9qwzxs.png\" alt=\"\" /></p>\n<h1 id=\"nasm\"><a class=\"anchor\" href=\"#nasm\">#</a> NASM</h1>\n<p><ins class=\"wavy\">NASM</ins>(<strong>N</strong>etwide <strong>As</strong>se<strong>m</strong>bler ) 是一个汇编器和反汇编器，支持 x86 和 x64，被设计的非常便携和模块化。它支持多种文件类型，包括 Linux and *BSD  <code>a.out</code> , ELF, Mach-O, 16-bit and 32-bit  <code>.obj</code>  (OMF) format, COFF (including its Win32 and Win64 variants.) ；还可以输出纯二进制文件，intel hex 和 Motorola S-Record 格式。他的语法被设计的极其简单且易于理解，有点类似于<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvd3d3L3VzL2VuL2RldmVsb3Blci9hcnRpY2xlcy90ZWNobmljYWwvaW50ZWwtc2RtLmh0bWw=\">英特尔软件开发者手册</span>中的语法但稍微复杂一点；他支持当前所有已知的 x86 架构。</p>\n<h2 id=\"安装-2\"><a class=\"anchor\" href=\"#安装-2\">#</a> 安装</h2>\n<div class=\"note warning\">\n<p>强烈建议通过 homebrew 完整安装，尽管 mac 中 Xcode 其实内置了 nasm，但功能有所阉割，可能会在后续过程导致未知错误。</p>\n</div>\n<p>nasm 的安装也非常简单，可以直接命令安装</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brew <span class=\"token function\">install</span> nasm</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> nasm</pre></td></tr></table></figure><p>当你使用 <code>nasm -h</code>  成功打印出帮助信息时，则代表安装完成了。</p>\n<hr />\n<p>以上就是我们在后面会用到的所有工具了，qemu 主要负责模拟一个硬件环境给我们写的操作系统去运行，而 nasm 则是帮助我们去将我们写的代码转换成机器码去给硬件执行，通过这两个工具，我们就可以进行操作系统的编写了🎉🎉🎉</p>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/00-preface/",
            "url": "https://gality.cn/os/00-preface/",
            "title": "序言-操作系统从0到1",
            "date_published": "2023-08-21T01:45:16.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第一篇文章，主要说明了本系列文章的目标、章节规划、前置知识储备及参考文章；文章编写力求图文丰富、逻辑完备，利用主线把知识串联起来，最终将从 0 到 1 实现一个操作系统所需要的知识都有机结合起来。</p>\n</div>\n<p>其实本科阶段在学习操作系统的时候就有跟着清华大学的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2tpdWtvdHN1L3Vjb3Jl\"> ucore 项目</span>，当时感觉学到了很多，但由于 ucore 是补充关键代码而非从真正意义上的 0 开始写一个操作系统，时至今日，细节已经完全模糊了，这是本系列产生的第一个原因。</p>\n<p>第二个原因也在于，之前在看 sakura 师傅的知乎问答时看到关于打基础的内容，提到了：&quot;自己写一个操作系统，并用自己的写的编译器来编译一个程序&quot;，又唤起了我之前的雄心，此时此刻，正适合有一个系列来记录这个过程，于是，<span class=\"rainbow\">Boooooom！</span></p>\n<h1 id=\"目标\"><a class=\"anchor\" href=\"#目标\">#</a> 目标</h1>\n<p>网上已经存在一些非常成熟的教程了，但可能或多或少都有一点点过时，软件版本的巨大变动使得过去教程中的一些东西可能有些过时（指的是工具部分，而非理论部分），这是我希望解决的第一个问题；同时我还希望能做到以下几点：</p>\n<ul>\n<li>\n<p>用丰富的图片去解析原理，用足够的资料去支撑理论。</p>\n</li>\n<li>\n<p>该系列将尽可能详细的对原理和实践进行解释，如果你仍然有疑问，欢迎评论，我会在看到后及时回复。</p>\n</li>\n<li>\n<p>最终实现一个微型操作系统，并在其上运行自己实现的编译器去编译运行一个程序。</p>\n</li>\n</ul>\n<h1 id=\"章节规划\"><a class=\"anchor\" href=\"#章节规划\">#</a> 章节规划</h1>\n<div class=\"note warning\">\n<p>非最终版，在系列结束后本部分会更新成确定版本</p>\n</div>\n<div class=\"note info\">\n<p>🎉🎉本系列的所有文章可以通过左手侧边栏中的系列文章索引进行快速到达～</p>\n</div>\n<ul>\n<li>序言</li>\n<li><a href=\"https://gality.cn/os/01-environment/\">环境准备</a></li>\n<li><a href=\"https://gality.cn/os/02-bios/\">BIOS 启动</a></li>\n<li>GDT 与保护模式</li>\n<li>虚拟内存实现</li>\n<li>加载并进入 kernel</li>\n<li>显示与打印</li>\n<li>全局描述符表 GDT</li>\n<li>中断处理</li>\n<li>虚拟内存完善</li>\n<li>实现堆和 malloc</li>\n<li>第一个 kernel 线程</li>\n<li>多线程切换</li>\n<li>锁于多线程同步</li>\n<li>进入用户态</li>\n<li>系统调用</li>\n<li>简单文件系统</li>\n<li>加载可执行文件</li>\n<li>键盘驱动</li>\n<li>运行 shell</li>\n</ul>\n<h1 id=\"前置知识储备\"><a class=\"anchor\" href=\"#前置知识储备\">#</a> 前置知识储备</h1>\n<p>操作系统本身就比较复杂，想自己实现操作系统并运行更需要很多其他的知识，这些知识中关于操作系统原理部分的知识会详细讲解，但涉及到工具的部分（模拟工具，编译工具等等）就不会过多的深入，只会讲一点于实现操作系统有关的部分，一切为主线服务。</p>\n<p>如果你已经具备以下知识，那么你可能可以较为轻松的接受本系列所讲知识，并将主要精力放在代码实践上，而如果你不是很了解以下知识，其实也没关系，不明白了就去搜索学习就好，带着问题学知识本身就是一种很好的学习方式，这些知识包括：</p>\n<ul>\n<li>C 语言能力</li>\n<li>一点 x86 汇编能力（可以在项目中提高）；</li>\n<li>熟练使用 Linux 系统，以及 Linux 下的系统编程经验；</li>\n<li>gcc，Makefile 等工具的使用；</li>\n<li>对编译，链接，执行代码的原理有足够的认识；</li>\n<li>硬件以及 OS 对内存的管理原理，尤其是虚拟内存；</li>\n<li>程序在操作系统中的加载，执行过程，内存的使用和分布；</li>\n<li>中断的概念和处理；</li>\n<li>进程，线程的概念及原理；</li>\n<li>多线程编程，同步与锁的概念；</li>\n</ul>\n<h1 id=\"参考文章\"><a class=\"anchor\" href=\"#参考文章\">#</a> 参考文章</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J1aWVycy9vcy10dXRvcmlhbC1jbi90cmVlL2NoaW5lc2U=\">https://github.com/ruiers/os-tutorial-cn/tree/chinese</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MDEyNDY1MA==\">https://segmentfault.com/a/1190000040124650</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9NYWluX1BhZ2U=\">https://wiki.osdev.org/Main_Page</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NmZW5vbGxvc2Evb3MtdHV0b3JpYWw=\">https://github.com/cfenollosa/os-tutorial</span></li>\n</ul>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列序言",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/daily/DailyRecord/",
            "url": "https://gality.cn/daily/DailyRecord/",
            "title": "九天揽月",
            "date_published": "2023-08-17T04:19:28.000Z",
            "content_html": "<div class=\"note info no-icon-with-header\">\n<h1 id=\"dig-deeper\"><a class=\"anchor\" href=\"#dig-deeper\">#</a> <ins class=\"danger\">Dig Deeper</ins></h1>\n<ol>\n<li>😁 记录不追求形式，以最舒服的方式进行记录即可。</li>\n<li>🗺️ 每天在总结时要总结所学内容在整体中的位置，不能只是闷着头只做知识储备。</li>\n<li>🧐 及时记录迸发的想法，哪怕无果而终，也要留有痕迹。</li>\n</ol>\n</div>\n<h1 id=\"daily-record\"><a class=\"anchor\" href=\"#daily-record\">#</a> Daily Record</h1>\n<h2 id=\"2023-第37周\"><a class=\"anchor\" href=\"#2023-第37周\">#</a> 2023 - 第 37 周</h2>\n<h3 id=\"97\"><a class=\"anchor\" href=\"#97\">#</a> 9.7</h3>\n<p>终于有时间做自己的事情了，上午修复了一下博客的评论 bug，为静态资源配置了 cdn 加速；下午看了会儿塔式服务器（万一用上呢！），然后继续修改部分预算问题并继续进行操作系统的更新，完成了保护模式的部分。</p>\n<h3 id=\"96\"><a class=\"anchor\" href=\"#96\">#</a> 9.6</h3>\n<p>上午完成了预算的初稿，下午去找了财务的老师核对各项问题，晚上还挺有状态的完成了操作系统的 <code>GDT</code>  和保护模式的部分内容，还不错～明天要把～～ <code>loader</code> ~~ 保护模式写完进入虚拟内存的章节啦</p>\n<h3 id=\"94-95\"><a class=\"anchor\" href=\"#94-95\">#</a> 9.4-9.5</h3>\n<p>预算工作第一版接近尾声，一定要把第一版写完，明天开始继续操作系统</p>\n<h2 id=\"2023-第35-36周\"><a class=\"anchor\" href=\"#2023-第35-36周\">#</a> 2023 - 第 35-36 周</h2>\n<h3 id=\"92-93\"><a class=\"anchor\" href=\"#92-93\">#</a> 9.2-9.3</h3>\n<p>周末基本在学校活动、应酬、改预算之间度过，操作系统 0...</p>\n<h3 id=\"91\"><a class=\"anchor\" href=\"#91\">#</a> 9.1</h3>\n<p>操作系统进度缓慢，明天尽量把预算弄完，然后好好学操作系统吧</p>\n<h3 id=\"831\"><a class=\"anchor\" href=\"#831\">#</a> 8.31</h3>\n<p>接触了点项目预算编写的知识并编写了一份财务预算说明书，抽了一点时间给操作系统的第四篇文章开了点头，希望两天内能完成第四章吧，加油！</p>\n<h3 id=\"830\"><a class=\"anchor\" href=\"#830\">#</a> 8.30</h3>\n<p>开学报道～参观了一下学校，体验了食堂，还是很不戳的～</p>\n<h3 id=\"827-829\"><a class=\"anchor\" href=\"#827-829\">#</a> 8.27-8.29</h3>\n<p>又是当懒狗的一天，摆了很长时间，好在迷途知返，抽了点时间看操作系统～</p>\n<h3 id=\"825-826\"><a class=\"anchor\" href=\"#825-826\">#</a> 8.25-8.26</h3>\n<p>抽空回家进行了各种档案工作，陪陪家人，基本摸不到电脑...</p>\n<p>不过还是利用一点点时间把操作系统第 3 章完成了✌️</p>\n<h3 id=\"824\"><a class=\"anchor\" href=\"#824\">#</a> 8.24</h3>\n<p>难得休息，打了打游戏，出去应酬了一圈，就没有进行学习任务 (爽～</p>\n<h3 id=\"823\"><a class=\"anchor\" href=\"#823\">#</a> 8.23</h3>\n<p><s class=\"danger\">终于，项目结束了，可以好好休息一下了，幸福到流泪😭</s></p>\n<p>上午完成了 baidu、google、bing 的 SEO 索引，等待一天时间就可以看分析数据了，可以通过改善关键字来提升 SEO 排名，既然准备好好经营，为什么不让更多人看到呢😊</p>\n<p><s>必须吐糟一下，baidu 的这个站长工具真的垃圾，google 3 分钟就配好了，就这个百度，用站长工具还需要实名认证，实名认证就算了，还需要扫脸，牛</s></p>\n<p>下午接着完成 <code>mbr</code>  编写的剩余部分的内容，还是剩一点点小尾巴没有完成，有一点点可惜，留着明天完成吧～😁</p>\n<h3 id=\"822\"><a class=\"anchor\" href=\"#822\">#</a> 8.22</h3>\n<p>整体效率还行，完成了博客的 aligolia 的搜索配置，完成了操作系统从 0 到 1 的第二篇文章，第三篇开了个头，使用 figma 作为画图工具还是有些大材小用了，浪费了点时间，需要找一个功能更简单、更便捷的画图工具！</p>\n<h3 id=\"821\"><a class=\"anchor\" href=\"#821\">#</a> 8.21</h3>\n<p>今天效率极低，只完成了操作系统序言部分的编写还大多都是借鉴别佬的，感觉稍微有点浮躁，没有沉下心，倒是听了很多财经的科普 hhh，明天要调整下状态好好学技术～</p>\n<h2 id=\"2023-第34周\"><a class=\"anchor\" href=\"#2023-第34周\">#</a> 2023 - 第 34 周</h2>\n<h3 id=\"820\"><a class=\"anchor\" href=\"#820\">#</a> 8.20</h3>\n<p>继续处理博客的遗留问题，包括：</p>\n<ul>\n<li>精选分类封面图片无法加载</li>\n<li>主题特殊样式学习</li>\n<li>主题样式的一点点 bug 的修复</li>\n<li>comment 表情包引入</li>\n<li>默认模版更新</li>\n</ul>\n<p>其实都是小问题，中间由于要调 bug，也去学习了一点 <code>Nunjunks</code>  和 <code>stylus</code>  语法，对于 hexo 的实现和现在使用的主题的实现都有了一定了解，可以更好 DIY 了😁</p>\n<p>对于博客的改动基本进入尾声了，之前预留的待踩坑项也都完成的七七八八了，后面就要注重内容的填充了，冲！</p>\n<h3 id=\"818-819\"><a class=\"anchor\" href=\"#818-819\">#</a> 8.18-8.19</h3>\n<p>虽然是偷偷摸摸，但终算有点时间打理一下博客，完成了博客配色的改变、评论管理系统搭建、图床的适配等等，基本将博客的整体架子搭出来了，后面就算再加，也只是功能的完善、调整或新增。现在其实更重要的是把博客的内容丰富起来了，加油！</p>\n<p>今天反思了一下过去写博客的经历，仔细想想其实之前也有过坚持日更坚持一年的情况，但是随着电脑的更换、服务器的到期最终连记录都已经找不到了，确实有点可惜，希望这次依托 github 可以将数据永久保留，使得我可以再走了很久之后可以回头看看自己来时的路。</p>\n<h3 id=\"817\"><a class=\"anchor\" href=\"#817\">#</a> 8.17</h3>\n<p>情况稍有转机，工作内容有了变化，可以使用自己的电脑了，做了 4 个 1day 的漏洞复现，也算是有些收获吧，顺便开始回忆起了一点点 web 手的记忆 hhh~</p>\n<h3 id=\"814-816\"><a class=\"anchor\" href=\"#814-816\">#</a> 8.14-8.16</h3>\n<p>本来雄心壮志且状态在线的立刻开始记录每日的学习，但实际上却被外部条件无奈的阻止了，迫不得已暂时停止开始坐牢...</p>\n",
            "tags": [
                "日常"
            ]
        },
        {
            "id": "https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/",
            "url": "https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/",
            "title": "blog搭建&Hello world",
            "date_published": "2023-08-14T08:02:17.000Z",
            "content_html": "<div class=\"note primary no-icon-with-header\">\n<h1 id=\"待踩坑项\"><a class=\"anchor\" href=\"#待踩坑项\">#</a> <ins class=\"danger\">待踩坑项</ins></h1>\n<p>🎉已经全部完成啦，后续将注重内容更新～🎉</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_0\"> valine admin: 通过脚本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Rlc2VydHNQL1ZhbGluZS1BZG1pbi5naXQ=\">一键部署</span>完成，<s class=\"info\">模版自身有点小 bug，通过调试 JS 解决</s> <s class=\"danger\">其实不算 bug，本质是配置问题，修改完配置后就没有 bug 了</s>  确实就是 bug，已经修复了 Orz</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> 文章图片：七牛云 + 学生认证 + 图片压缩 + CDN 加速，目前图片加载速度较为满意</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_2\"> 主题样式更改以更符合自己口味：已完成白天 &amp; 黑夜两套色系的适配， 顺便推荐一下飞书，UI 配色真的很好抄 (博客白天模式的配色和本人命令行均是～)</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_3\"> 默认图片：通过图传解决，plus：添加更多图片以减少随机的重复</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_4\"> 主题特殊样式：<span class=\"rainbow\">该页面已通过主题特殊样式复写～</span></label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_5\"> 主页精选分类实现：花费了半天成功实现，中间有些坑值得记录一下，详见：<a href=\"https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/#%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E6%AD%A3%E5%B8%B8%E4%BD%86%E9%83%A8%E7%BD%B2%E5%90%8E404\">这里</a></label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_6\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_6\"> Valine 表情源引入：使用了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dhbWVyTm9UaXRsZS9WYWxpbmUtTWFnaWM=\"> Valine-Magic</span> 的表情源来实现</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_7\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_7\"> 主题样式 bug 修复：修复当标题在标签块中时样式重叠的 bug</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_8\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_8\"> 主题样式功能新增：<s>新增对 front-matter 中 summary 字段的支持</s>，使用 <code>excerpt</code>  即可实现摘要编写工功能</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_9\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_9\"> 主题样式功能修正：不知道是因为改动了哪里，导致文章中的超链接样式没有下滑线，通过对代码进行修正修复了这个问题。</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_10\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_10\"> algolia: 申请完成并且在今天完成了配置，其中遇见一点点小坑 (配置原因)，很快便解决了</label></p>\n</li>\n</ul>\n<p>2023.9.7 补</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_11\"> MiniValine Bug 修复：页脚最新评论因多加 <code>/</code>  导致无法正确跳转到文章评论，通过改变 MiniValine 解决了这个问题。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_12\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_12\"> 本地资源走 jsdeliver 进行 CDN 加速：速度提升巨大，真心感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==\"> jsdelivr</span> 这样的免费项目。</label></li>\n</ul>\n</div>\n<h1 id=\"blog-搭建\"><a class=\"anchor\" href=\"#blog-搭建\">#</a> Blog 搭建</h1>\n<p>无法白嫖阿里云 or 腾讯云的学生优惠后，用个人云服务器作为博客的花费属实有点不能承受，于是又回归了 <code>Github Pages + Hexo</code>  的白嫖之路，途中踩到了诸多坑，这里稍微记录一下：</p>\n<h2 id=\"主题\"><a class=\"anchor\" href=\"#主题\">#</a> 主题</h2>\n<p>逛<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy9pbmRleC5odG1s\"> themes</span> 的时候偶然看见了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==\"> ShoKa</span> 主题，除了有点太过二次元外特效和布局还是很对我胃口的，唯一一点在于作者两年前就不更新了，看到最后一次更新时间时，我就意识到，安装之旅一定时会踩坑的...，咬咬牙，还是踩一遍吧</p>\n<h2 id=\"node版本\"><a class=\"anchor\" href=\"#node版本\">#</a> node 版本</h2>\n<p>作为一个两年前的项目，用最新 LTS 版本 18.17.1 果不其然会出问题，主要在于该项目所依赖的插件 <code>hexo-renderer-multi-markdown-it</code>  中依赖了 <code>puppeteer</code> ，在已经解决了网络问题的情况下，仍然会报一个错误：</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>TypeError <span class=\"token punctuation\">[</span><span class=\"token constant\">ERR_INVALID_PROTOCOL</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> Protocol <span class=\"token string\">\"https:\"</span> not supported<span class=\"token punctuation\">.</span> Expected <span class=\"token string\">\"http:\"</span></pre></td></tr></table></figure><p>最终解决方法为将 node 版本降至 12.x：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> n <span class=\"token number\">12.22</span>.12</pre></td></tr></table></figure><h2 id=\"deploy插件\"><a class=\"anchor\" href=\"#deploy插件\">#</a> deploy 插件</h2>\n<p>hexo 官方的 deploy 插件为： <code>hexo-deployer-git</code> ，提供了一键部署功能，而官方文档给的不是特别详细，token 变量赋值为 github 的 access token 仍然无法认证成功，这里直接给出认证成功的配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//Your_Access_Token@github.com/&lt;Name<span class=\"token punctuation\">></span>/&lt;Name<span class=\"token punctuation\">></span>.github.io</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> main</pre></td></tr></table></figure><h2 id=\"包管理器\"><a class=\"anchor\" href=\"#包管理器\">#</a> 包管理器</h2>\n<p>不知道是不是因为 node 降级之后没有把 <code>yarn</code>  降级的原因，当我用 <code>yarn add xxx</code>  安装依赖后，再次使用 <code>hexo</code>  指令时，会出现报错 <code>cannot find module 'hexo'</code> ，这里没有继续探究下去了，直接放弃 <code>yarn</code> ，使用 <code>npm</code>  就没有问题了。</p>\n<h2 id=\"leancloud-valine\"><a class=\"anchor\" href=\"#leancloud-valine\">#</a> LeanCloud + Valine</h2>\n<p>该主题默认支持了使用 <code>valine+LeanCloud</code>  的方式实现无后端评论功能，有问题的地方在于 leanCloud 现在做了默认策略，无法通过默认地址进行访问，必须通过 <code>应用 -&gt; 设置 -&gt; 应用凭证 -&gt; 域名白名单</code> 中的 Request 域名进行访问，在 <code>_config.yaml</code>  中的配置项中，必须在 <code>serverURLs</code>  为上述域名 <code>xxxx.api.lncldglobal.com</code>  才可以正常使用</p>\n<h2 id=\"本地预览正常但部署后404\"><a class=\"anchor\" href=\"#本地预览正常但部署后404\">#</a> 本地预览正常但部署后 404</h2>\n<p>刚开始遇见这个问题是在实现分类图片时，图片就在 github 的仓库对应位置，但是加载页面时却 404，用英文搜了好久但其实没有搜到点上，这个问题的本质在于，默认 njk 模版在引用图片时使用的是绝对路径 <code>/MISC/cover.jpg</code> ，本地没有问题，但是部署到 github 后会出现无法访问的情况，此时将模版更改为 <code>MISC/cover.jpg</code>  即可，对我来说，问题的复杂在于，刚开始没有定位到问题，以为是 url 路径大小写的问题，所以就把 <code>MISC</code>  改为了 <code>misc</code> ，这有导致了新的问题，这个才是更值得记录。</p>\n<p>由于 URL 路径对于大小写是敏感的，所以如果服务器路径为 <code>http://xx.com/misc/cover.jpg</code> ，那么此时，用 <code>http://xx.com/MISC/cover.jpg</code>  是访问不到的，所以我在更改大小写后，仍然有 404 的问题，且此时，我注意到在本地的 public 文件夹中， <code>MISC</code>  文件夹已经变为了 <code>misc</code> ，但 <code>hexo d</code>  后，github 仓库中仍然为 <code>MISC</code> ，原因在于 git 本身是对大小写不敏感的，即 <code>MISC</code>  和 <code>misc</code>  对于 git 来说是一样的，而 hexo 本身又是差量更新，所以大小写的变动并没有记录更新，仍然用之前的大写版本，该问题的解决方法如下：</p>\n<ol>\n<li>修改 <code>&lt;root&gt;/.deploy_git/.git/config</code>  文件，将 <code>gnorecase = true</code>  改为 <code>false</code>  (使得 git 对大小写敏感)</li>\n<li>删除 <code>&lt;root&gt;/.deploy_git</code>  下的 <code>MISC</code>  文件夹 (该文件夹内才是真正的 git 仓库)</li>\n<li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>  重新部署</li>\n</ol>\n<div class=\"note warning no-icon\">\n<p>PS：图片路径问题的本质其实是主题原本的写法是用了 jsdelivr 去加速静态资源的，当配置了 <code>statics</code>  为 jsdelivr 地址时，资源加载不会出错，如果是配置为 <code>/</code> ，则会存在上述问题。</p>\n</div>\n<h2 id=\"jsdelivr加速及刷新缓存\"><a class=\"anchor\" href=\"#jsdelivr加速及刷新缓存\">#</a> Jsdelivr 加速及刷新缓存</h2>\n<p>对于 github 项目来说，配置 Jsdelivr 加速极其简单，直接将资源的访问链接替换成 CDN 链接即可，CDN 链接为：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>https://cdn.jsdelivr.net/gh/您的Github用户名/项目仓库名@版本/文件路径</pre></td></tr></table></figure><p>例如，我自己改过的 MiniValine 的地址为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dhbGl0eTM2OS9NaW5pVmFsaW5lL2Rpc3QvTWluaVZhbGluZS5taW4uanMlRUYlQkMlOEMlRTUlOEYlOTElRTUlQjglODMlRTQlQkElODYlRTQlQjglODAlRTQlQjglQUFyZWxlYXNlJUU3JTg5JTg4JUU2JTlDJUFDJUU0JUI4JUJBJUUyJTgwJTlDdjQuMi4yLWJldGExMSVFMiU4MCU5RCVFMyU4MCU4Mg==\">https://github.com/Gality369/MiniValine/dist/MiniValine.min.js，发布了一个 release 版本为 “v4.2.2-beta11”。</span></p>\n<p>那么我只需将地址替换为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2dhbGl0eTM2OS9NaW5pVmFsaW5lQHY0LjIuMi1iZXRhMTEvZGlzdC9NaW5pVmFsaW5lLm1pbi5qcyVFNSVCMCVCMSVFNSU4RiVBRiVFNCVCQiVBNSVFOCVBRSVBOWpzZGVsaXZlciVFNiU4QSU5MyVFNSU4RiU5NiVFNiU4OCU5MSVFNyU5QSU4NGpzJUU2JTk2JTg3JUU0JUJCJUI2JUU1JUI5JUI2JUU5JTgwJTlBJUU4JUJGJTg3Q0ROJUU1JThBJUEwJUU5JTgwJTlGJUU0JUJDJUEwJUU3JUJCJTk5JUU2JTg4JTkxJUUzJTgwJTgy\">https://cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js 就可以让 jsdeliver 抓取我的 js 文件并通过 CDN 加速传给我。</span></p>\n<p>注意，这其中涉及到缓存问题，例如当我改变了上述 js 文件后，由于 jsdelivr 会存一份缓存文件便于加速获取过程，所以当我请求时可能只能获取老版本的 js，我们可以通过将 <code>cdn</code>  换成 <code>purge</code>  的方式来告诉 jsdelivr 重新获取文件并刷新缓存，例如：</p>\n<pre><code>//刷新前\nhttps://cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js\n\n//强制刷新，返回 status: finished 代表刷新成功\nhttps://purge.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js\n\n//重新访问即可\nhttps://cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js\n</code></pre>\n<p>jsdelivr 大幅提升了网站的访问速度，最重要的是免费！！！</p>\n<p>再次由衷感谢这样的项目🙏</p>\n<h1 id=\"hello-world\"><a class=\"anchor\" href=\"#hello-world\">#</a> Hello World</h1>\n<p>仔细算算搭建个人博客已经有过大概 7、8 次了，每次总是因为各种各样的原因，最终都荒废了，记录的笔记，分享的技术也都遗失了，确实也有点遗憾。</p>\n<p>本来计划等开学之后再重新搭博客来记录 &amp; 激励自己，但是在认真看了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ldGVybmFsc2FrdXJhMTMuY29tLw==\"> Sakura 师傅</span>的博客之后，大受震撼，几经思索之后，不禁问自己为什么要等到 10 几天后呢？为什么不能现在开始呢？于是，说做便做，今天便将诸多坑都踩了踩，产出了新博客的第一篇文章。</p>\n<p>博客将具体怎么发展，写那些内容，暂时还没有想好，但是一定会置顶一篇自己的每日进展作为激励，希望可以一直坚持下去，每天更新。</p>\n<p>末了，写一句激励自己的话吧！</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"泰山之管穿石，单极之绠断干。水非石之钻，索非木之锯，渐靡使之然也\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "杂项",
                "踩坑",
                "杂项",
                "踩坑"
            ]
        }
    ]
}