{
    "version": "https://jsonfeed.org/version/1",
    "title": "藏器于身",
    "subtitle": "待时而动",
    "icon": "https://gality.cn/images/favicon.ico",
    "description": "安全杂记 & 日常随感",
    "home_page_url": "https://gality.cn",
    "items": [
        {
            "id": "https://gality.cn/misc/trail-and-error/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8GDB/",
            "url": "https://gality.cn/misc/trail-and-error/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8GDB/",
            "title": "Mac下使用GDB进行调试",
            "date_published": "2023-09-13T09:39:27.000Z",
            "content_html": "<div class=\"note info no-icon\">\n<p>以下为本文所使用的系统环境与版本：</p>\n<ul>\n<li>macOS Ventura 13.4.1 (c) - 英特尔芯片</li>\n<li>GDB 13.2</li>\n</ul>\n</div>\n<h1 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h1>\n<h2 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h2>\n<p>Mac 下安装 <code>gdb</code>  非常简单，直接使用 <code>homebrew</code>  安装即可：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>brew <span class=\"token function\">install</span> gdb</pre></td></tr></table></figure><h2 id=\"问题\"><a class=\"anchor\" href=\"#问题\">#</a> 问题</h2>\n<p>直接使用 <code>gdb</code>  运行调试运行其他程序会出现以下报错：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> r</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Starting program: /Users/gality/project/v8/out/xcode.debug/d8</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Unable to <span class=\"token function\">find</span> Mach task port <span class=\"token keyword\">for</span> process-id <span class=\"token number\">13210</span>: <span class=\"token punctuation\">(</span>os/kern<span class=\"token punctuation\">)</span> failure <span class=\"token punctuation\">(</span>0x5<span class=\"token punctuation\">)</span>.</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>please check gdb is codesigned - see taskgated<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">))</span></pre></td></tr></table></figure><p>此处错误的原因是 Mac 系统默认禁止一个未授权的进程访问 / 调试其它进程（防止安全问题）。想让内核解除这种限制，最好的方法就是用系统信任的证书对它进行签名。</p>\n<h1 id=\"解决方案\"><a class=\"anchor\" href=\"#解决方案\">#</a> 解决方案</h1>\n<h2 id=\"创建证书\"><a class=\"anchor\" href=\"#创建证书\">#</a> 创建证书</h2>\n<ol>\n<li>打开 <ins class=\"dot\">钥匙串访问.app</ins></li>\n<li>在右上角菜单栏中 <span class=\"label info\">钥匙串访问</span> -&gt; <span class=\"label info\">证书助理</span> -&gt;  <span class=\"label info\">创建证书</span></li>\n<li>填写信息：\n<ul>\n<li>名称：gdb_codesign</li>\n<li>身份类型：自签名根证书</li>\n<li>证书类型：代码签名</li>\n<li>勾选：让我覆盖这些默认值</li>\n</ul>\n</li>\n<li>使用默认设置，一直点击确定到 <ins class=\"dot\">指定证书位置</ins> 的步骤，选择 <span class=\"label info\">系统</span> 后，按提示完成创建</li>\n<li>在 <ins class=\"dot\">钥匙串访问.app</ins> 中，选择左侧栏的  <span class=\"label dot\">系统</span> 内的 <span class=\"label info\">我的证书</span> 栏目，找到刚刚创建的<ins class=\"dot\"> gdb_codesign</ins> 证书并双击打开 <ins class=\"dot\">证书信息窗口</ins> ，展开 <span class=\"label info\">信任</span> 项，设置 ++ 使用此证书时: ++{.dot} 为<strong>始终信任</strong>。</li>\n<li>关闭 <ins class=\"dot\">证书信息窗口</ins> 时，会再次输入密码。</li>\n</ol>\n<h2 id=\"对gdb签名\"><a class=\"anchor\" href=\"#对gdb签名\">#</a> 对 GDB 签名</h2>\n<p>先在 <code>家目录下</code> 创建一个 <code>gdb-entitlement.xml</code> ，然后写入以下内容：</p>\n<figure class=\"highlight xml\"><figcaption data-lang=\"XML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">plist</span> <span class=\"token name\">PUBLIC</span> <span class=\"token string\">\"-//Apple//DTD PLIST 1.0//EN\"</span> <span class=\"token string\">\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>plist</span> <span class=\"token attr-name\">version</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>1.0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dict</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>key</span><span class=\"token punctuation\">></span></span>com.apple.security.cs.debugger<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>key</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>true</span><span class=\"token punctuation\">/></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dict</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>plist</span><span class=\"token punctuation\">></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>pre</span><span class=\"token punctuation\">></span></span></pre></td></tr></table></figure><p>接着在 <code>家目录</code> 下执行以下命令，用我们刚刚创建的证书对 gdb 进行签名：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> codesign <span class=\"token parameter variable\">--entitlements</span> gdb-entitlement.xml <span class=\"token parameter variable\">-fs</span> gdb_codesign /usr/local/bin/gdb</pre></td></tr></table></figure><p>「如果你是用 <code>brew install gdb</code>  安装的 <code>gdb</code>  的话，那么其默认路径应该在 <code>/usr/local/bin/gdb</code> ，否则，可以使用 <code>whereis gdb</code>  命令来找到 <code>gdb</code>  的安装路径」</p>\n<hr />\n<p>此时，再次尝试使用 GDB 去调试别的应用，就可以正常调试啦！🎉🎉🎉</p>\n<div class=\"note info no-icon\">\n<p>在许多教程中（包括官方教程），均要求签名完成后必须重启电脑来使签名生效，不过我实际测试是不需要重启也可以生效的，如果你在前签名完成后仍然有问题，不妨重启下试试。</p>\n</div>\n<h1 id=\"已知bug\"><a class=\"anchor\" href=\"#已知bug\">#</a> 已知 Bug</h1>\n<p>如果出现如下情况：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> r</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Starting program: /Users/gality/project/V8/v8/out/xcode.debug/d8</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>New Thread 0x2303 of process <span class=\"token number\">16191</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>然后卡住不动，可以使用快捷键 <span class=\"kbd\">Ctrl</span> + <span class=\"kbd red\">C</span> 来中断，然后就可以正常调试了。</p>\n<p>这个 Bug 经常出现于首次使用 <code>gdb</code>  调试时，中断后正常进入调试程序，且一般再次调试时就不会触发这个 Bug 了。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3Jhdml0eWxvdy9mYjU5NTE4NmNlNjA2ODUzN2E2ZTlkYTZkOGI1Yjk2ZA==\">https://gist.github.com/gravitylow/fb595186ce6068537a6e9da6d8b5b96d</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vub25vaS9hcnRpY2xlL2RldGFpbHMvMTI4NjMwMzMw\">https://blog.csdn.net/unonoi/article/details/128630330</span></li>\n</ul>\n",
            "tags": [
                "杂项",
                "踩坑",
                "杂项",
                "踩坑",
                "GDB"
            ]
        },
        {
            "id": "https://gality.cn/os/03-loader/",
            "url": "https://gality.cn/os/03-loader/",
            "title": "03-Loader编写之进入保护模式",
            "date_published": "2023-08-31T08:08:10.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第四篇文章，主要讲解了 loader 需要完成的任务以及其中涉及到的知识点。本章先总体介绍 loader 的工作，然后逐步实现部分 loader 的工作（虚拟内存之前）并讲解相关知识点，由于虚拟内存相关的知识庞大且重要，我们会在下一章进行详细探讨。</p>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: GDT, protected mode, segment register, interrupts, pipeline</em></p>\n</div>\n<h1 id=\"loader的工作\"><a class=\"anchor\" href=\"#loader的工作\">#</a> Loader 的工作</h1>\n<p>总的来说，loader 的工作为以下几项（也是 loader 到 kernel 的步骤）：</p>\n<ol>\n<li>禁用中断</li>\n<li>建立 GDT</li>\n<li>进入保护模式并刷新 cpu 管道、初始化段寄存器和栈</li>\n<li>建立 kernel 页目录（ <code>page directory</code> ）和页表（ <code>page tables</code> ）</li>\n<li>打开虚拟内存（ <code>virtual memory</code> ），进入  <code>paging</code>  模式</li>\n<li>加载  <code>kernel</code>  镜像到内存</li>\n<li>执行 <code>kernel</code>  代码，控制权转交给 <code>kernel</code></li>\n</ol>\n<h1 id=\"loader编写\"><a class=\"anchor\" href=\"#loader编写\">#</a> Loader 编写</h1>\n<h2 id=\"禁用中断\"><a class=\"anchor\" href=\"#禁用中断\">#</a> 禁用中断</h2>\n<p>禁用中断通过设置 <code>IF</code> flag 来实现，当 <code>IF</code> flag 被设置为 0 时，系统会屏蔽中断命令；禁用中断非常简单，只需要一行命令即可：</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cli</pre></td></tr></table></figure><p>如果你看了很多教程的话，可能会发现，有的教程中有这行代码，而有的没有，甚至在自己写的 loader 中不禁用中断可能也不会有什么问题，但是，这里是 “可能”，如果中断发生在实模式进入保护模式之前和之后，系统都没有问题，但在模式切换进行时发生中断就会发生异常。这个情况概率比较低，少量的验证是没法复现此问题的，所以我们最好还是加上 <code>cli</code>  命令。</p>\n<h2 id=\"建立gdt\"><a class=\"anchor\" href=\"#建立gdt\">#</a> 建立 GDT</h2>\n<details class=\"info\"><summary>什么是GDT？</summary><div>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HRFRfVHV0b3JpYWw=\">GDT</span>（ <strong>Global Descriptor Table</strong>）即全局描述符表，又叫段描述符表，本质其实就是一种专用于 <code>IA-32</code>  和 <code>x86-64</code>  体系结构的二进制数据结构，该表位于内存中，具体位置保存在 <code>GDTR</code>  寄存器中，其条目描述并规定了不同内存分区的各种特征，包括基地址、大小和访问特权如可执行、可写等。 在 Intel 的术语中，这些内存区域被称为 <code>segment</code> 。</p>\n<p>我们在上一章中提到过，CPU 通过 <code>段基地址</code>  + <code>段内偏移</code> 的方式来扩展寻址空间，类似的，在保护模式下，CPU 通过 GDT 中记录的基地址和偏移地址实现寻址，因此可以通过 GDT 中记录的段的信息来进行内存的保护（对比实模式下，所有程序都可以访问任意内存）。</p>\n</div></details>\n<h3 id=\"gdtr\"><a class=\"anchor\" href=\"#gdtr\">#</a> GDTR</h3>\n<p>根据<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HbG9iYWxfRGVzY3JpcHRvcl9UYWJsZQ==\">手册</span>，GDT 的地址应存储在 <code>GDTR</code>  寄存器中，这个过程通过汇编指令 <code>LGDT</code>  进行加载，参数指向 <code>GDT Descriptor</code>  结构：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/qsb20j.png\" alt=\"GDT Descriptor\" /></p>\n<ul>\n<li><strong>Size</strong>：表示 GDT 的大小，以字节为单位，实际大小值为 <code>Size+1</code> ，这是因为 <code>Size</code>  的最大值是 65535，但是 GDT 的最大值为 65536（8192 条数据）；同时，GDT 的 <code>Size</code>  不能为 0</li>\n<li><strong>Offest</strong>：GDT 的线性地址（并不是物理地址，而是分页地址）</li>\n</ul>\n<p>同时，上图中我们也可以看出 <code>LGDT</code>  命令在 32 位和 64 位下采用不同的方式载入数据， <code>Offest</code>  在 32 位下只有 4 字节长度，而在 64 位下有 8 字节。</p>\n<h3 id=\"gdt\"><a class=\"anchor\" href=\"#gdt\">#</a> GDT</h3>\n<p>GDT 中的条目占 8 字节，在内存中的形式如下：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/ug568w.png\" alt=\"GDT\" /></p>\n<p>注意，GDT 中的第一个条目 (Entry 0) 永远为空，所以段数据应从第二个条目开始存储；表中的项由段选择器（Segment Selectors）存取，段选择器通过汇编指令或中断等硬件函数加载到段寄存器中。</p>\n<p>GDT 中每一项都有一个名为 <code>Segment Descriptor</code>  复杂的结构，该结构长度为 8 Bytes，示意图如下：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/ir3ukr.png\" alt=\"System Segment Descriptor\" /></p>\n<ul>\n<li><strong>Base</strong>：一个 32 位值（不连续的黄色部分），记录了该段的起始地址「图中 Base address 后的括号说明了改部分在整个 Base 中的位数」</li>\n<li><strong>Limit</strong>：一个 20 位值（不连续的粉红色部分），记录最大可寻址单元，以 1 字节为单位（最大寻址 1M），或以 1 页（4 KB）为单位；因此，在 32 位下，如果选择以页为单位且 limit 设为 <code>0xFFFFF</code> ，那么该段将覆盖整个 4 GB（4KB*1M ）空间「图中括号内数字含义同 Base」</li>\n</ul>\n<details class=\"info\"><summary>64位下的GDT</summary><div>\n<p>上述图片展示的是 32 位模式下的 GDT，而在 64 位模式下，段保护机制基本被废弃了，更多的是使用页机制，因此，服务于段机制的 GDT 表项就少很多；又由于 64 位下引入的 <code>IA-32e</code>  指令集不再兼容老旧的 8086 模式，仅有代码段 CS，数据段 DS 仍和 32 位一样使用 64 位，即 8 字节的描述符，其他的段寄存器例如：DS、ES、SS 这样的段寄存器已经不再使用了，GDT 项存在的意义就更小了。</p>\n<p>另一个导致 GDT 在 64 位下不受宠的原因是，其实从 win XP 系统开始，系统进入保护模式后 GDT 的项就没用了，一直就那么空在内存中，甚至还有从系统启动到结束就没用过的表项，不但占地方还给了黑客可趁之机，很多大神看上了这一大片有可读写可执行属性的内存，就把 Shellcode 或者全局数据区布置在这了。</p>\n</div></details>\n<ul>\n<li>\n<p><strong>Access Byte</strong>：一个 8 位值（40-47），代表了该段的访问权限字段，字段参数及含义如下：</p>\n<ul>\n<li>\n<p><strong>P:</strong> 段是否存在，存在 = 1</p>\n</li>\n<li>\n<p><strong>DPL:</strong> 描述符权限级别字段（2 位）， 即该段的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9TZWN1cml0eSNSaW5ncw==\"> CPU 权级</span>. <strong>0</strong> = 最高权限（内核）, <strong>3</strong> = 最低权限（用户应用）.</p>\n</li>\n<li>\n<p><strong>S:</strong> 描述符类型字段。如果设置为 <code>0</code> ，则定义了一个系统段 (例如 TSS「 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9UYXNrX1N0YXRlX1NlZ21lbnQ=\">Task State Segment</span> 」、LDT「 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9Mb2NhbF9EZXNjcmlwdG9yX1RhYmxl\">Local Descriptor Table</span> 」)；如果设置为 <code>1</code> ，则定义一个代码段或数据段。这两种描述符的 Type 字段结构有所不同，接下来分别来说：</p>\n<div class=\"note success no-icon\">\n<p><strong>S=0</strong> 时（System Segment Descriptor）</p>\n<ul>\n<li><strong>Type</strong>：定义系统段的类型（32 位模式）\n<ul>\n<li><strong>0x1:</strong> 16-bit TSS (Available)</li>\n<li><strong>0x2:</strong> LDT</li>\n<li><strong>0x3:</strong> 16-bit TSS (Busy)</li>\n<li><strong>0x9:</strong> 32-bit TSS (Available)</li>\n<li><strong>0xB:</strong> 32-bit TSS (Busy)</li>\n</ul>\n</li>\n<li><strong>Type</strong>：定义系统段的类型（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ19tb2Rl\">Long Mode</span>）\n<ul>\n<li><strong>0x2:</strong> LDT</li>\n<li><strong>0x9:</strong> 64-bit TSS (Available)</li>\n<li><strong>0xB:</strong> 64-bit TSS (Busy)</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"note success no-icon\">\n<p><strong>S=1</strong> 时（Code/Data Segment），<strong>Type</strong> 字段会被拆分为以下字段</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/shts2l.png\" alt=\"Access Byte\" /></p>\n<ul>\n<li><strong>E</strong>：第 43 位，是否可执行位， <code>0</code>  代表该段为数据段，不可执行； <code>1</code>  代表代码段，可执行</li>\n<li><strong>DC</strong>：第 42 位，方向位 / 符合位\n<ul>\n<li>对于数据段：表示方向位。 <code>0</code>  代表段向高地址增长； <code>1</code>  代表段向低地址生长</li>\n<li>对于代码段：表示符合位。 <code>0</code>  代表只有 <code>DPL</code>  字段中指定的权限可以执行该段代码； <code>1</code>  表示该段代码的执行权限可以小于等于 <code>DPL</code></li>\n</ul>\n</li>\n<li><strong>RW</strong>：第 41 位，可读 / 可写位\n<ul>\n<li>对于代码段：表示可读位。 <code>0</code>  代表该段不允许读， <code>1\t</code> 代表可读；代码段永远没有写权限。</li>\n<li>对于数据段：表示可写位。 <code>0</code>  代表该段不可写， <code>1</code>  代表可写；数据段永远有读权限。</li>\n</ul>\n</li>\n<li><strong>A</strong>：第 40 位，访问位，最好设置为 0，CPU 会在该段被访问时自动设置它。</li>\n</ul>\n</div>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Flags</strong>：一个 4 位值（52-55 位）</p>\n<ul>\n<li><strong>G</strong>：粒度位，指示 <code>Limit</code>  的单位。 <code>0</code>  表示 <code>Limit</code>  单位为 1 字节 (字节粒度)。如果设置为 <code>1</code> ，则 <code>Limit</code>  单位为 4KB 块 (页面粒度)。</li>\n<li><strong>DB</strong>：大小位， <code>0</code>  代表定义了一个 16 位保护模式段， <code>1</code>  表示定义了一个 32 位保护模式段；一个 GDT 可以同时有 16 位和 32 位的位选择器</li>\n<li><strong>L</strong>：长模式代码标志， <code>1</code>  表示该段定义为 64 位代码段，此时 <code>DB</code>  应该设置位 <code>0</code> ； <code>0</code>  表示为其他类型段</li>\n<li><strong>A</strong>：保留位，设为 0 即可</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"asm\"><a class=\"anchor\" href=\"#asm\">#</a> asm</h3>\n<p>以上就是所有有关 <code>GDT</code>  的理论知识啦，现在让我们动手写一下我们的操作系统的 <code>GDT</code>  吧！梳理一下：</p>\n<ol>\n<li><code>GDT</code>  的第一项必须为空项</li>\n<li>至少定义两个段：代码段、数据段（ <code>base</code>  和 <code>length</code>  先一样即可）</li>\n<li>获取 <code>GDT</code>  的地址</li>\n<li>创建 <code>GDT Descriptor</code>  结构用于后续填充 <code>GDTR</code></li>\n</ol>\n<details class=\"info\"><summary>32bit-gdt.asm</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token label function\">gdt_start:</span> <span class=\"token comment\">; don't remove the labels, they're needed to compute sizes and jumps</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">; the GDT starts with a null 8-byte</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    dd <span class=\"token number\">0x0</span> <span class=\"token comment\">; 4 byte</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    dd <span class=\"token number\">0x0</span> <span class=\"token comment\">; 4 byte</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">; GDT for code segment. base = 0x00000000, length = 0xfffff</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">; for flags, refer to os-dev.pdf document, page 36</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token label function\">gdt_code:</span> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    dw <span class=\"token number\">0xffff</span>    <span class=\"token comment\">; segment length, bits 0-15</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    dw <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 0-15</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    db <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 16-23</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    db <span class=\"token number\">10011010b</span> <span class=\"token comment\">; flags (8 bits)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    db <span class=\"token number\">11001111b</span> <span class=\"token comment\">; flags (4 bits) + segment length, bits 16-19</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    db <span class=\"token number\">0x0</span>       <span class=\"token comment\">; segment base, bits 24-31</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">; GDT for data segment. base and length identical to code segment</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">; some flags changed, again, refer to os-dev.pdf</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token label function\">gdt_data:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    dw <span class=\"token number\">0xffff</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    dw <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    db <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    db <span class=\"token number\">10010010b</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    db <span class=\"token number\">11001111b</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    db <span class=\"token number\">0x0</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token label function\">gdt_end:</span> <span class=\"token comment\">; don't remove this label</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">; GDT descriptor</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token label function\">gdt_descriptor:</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    dw gdt_end <span class=\"token operator\">-</span> gdt_start <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token comment\">; size (16 bit), always one less of its true size</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    dd gdt_start <span class=\"token comment\">; address (32 bit)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\">; define some constants for later use</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>CODE_SEG equ gdt_code <span class=\"token operator\">-</span> gdt_start</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>DATA_SEG equ gdt_data <span class=\"token operator\">-</span> gdt_start</pre></td></tr></table></figure></div></details>\n<p>上面的代码中其实还隐藏了一个知识点，仔细想想也确实会有一个并不是很合逻辑的地方。我们知道在高级语言，例如 <code>C语言</code> 中，一个一个的创建变量并不能保证变量在内存中是连续存储的，除非用数组；但是我们的代码里面并没有任何的特殊数据结构的形式，那么 <code>GDT</code>  的每一项在内存中是一定在一起的吗？</p>\n<details class=\"primary\"><summary>如果是，那么这代表什么？如果不是，那么实际又是怎么实现的呢？</summary><div>\n<p>答案：<strong>一定是在一起</strong>。这是因为汇编源代码里的指令和数据部分是可以自由混杂排布的，而且最终编译出来的二进制中，它们排布顺序完全遵循源代码的排布。所以你可以任意安排你的指令和数据所处的位置，只需记得要使用各种跳转指令来控制代码运行即可。</p>\n<p>但是，整个  <code>loader</code>  的起始位置，即入口代码必须在  <code>0x9000</code>  处，因为这是和  <code>mbr</code>  约定好的跳转地址（详见<a href=\"https://gality.cn/os/02-mbr/\">上一章</a>），至于后面全部可以自由发挥和排布。</p>\n<p>其实，这个特性又是另外一个问题的答案，不知道有没有读者在看前面的代码时有这么一个疑问，为什么都要在代码结束加上 <code>jmp $</code> ，一定要加吗？</p>\n<p>当然<strong>是的</strong>，这个问题的答案同样是来源于上述特性，如果不加上 <code>jmp $</code>  来使代码进入死循环，那么代码将继续向后执行，将随机乱码理解成代码去执行，这样会导致未知错误。</p>\n</div></details>\n<h2 id=\"保护模式\"><a class=\"anchor\" href=\"#保护模式\">#</a> 保护模式</h2>\n<h3 id=\"设置gdtr\"><a class=\"anchor\" href=\"#设置gdtr\">#</a> 设置 GDTR</h3>\n<p>上一步中我们已经定义了 <code>GDT</code>  和 <code>GDT Descriptor</code>  结构，只需要使用 <code>lgdt [gdt_descriptor]</code>  命令来将 <code>GDT Descriptor</code>  的地址加载到 <code>GDTR</code>  寄存器中即可。</p>\n<h3 id=\"进入保护模式\"><a class=\"anchor\" href=\"#进入保护模式\">#</a> 进入保护模式</h3>\n<p>设置完 <code>GDT</code>  后我们就可以使 CPU 进入保护模式了，进入保护模式非常简单，只需要设置 CPU 的 <code>cr0</code>  寄存器即可。 <code>cr0</code>  寄存器是一个控制寄存器，共 32 位，每一位都对应着不同的控制能力，我们这里无需管其他位的能力，只需要关注第 0 位 PE（Protected Enable）位即可，当 <code>PE=0</code>  时，启动保护模式； <code>PE=1</code>  时，则在实模式运行。</p>\n<p>我们在对 cr0 寄存器进行操作时还必须注意需要保留其他控制位值不变，想到了什么操作？没错，就是 <code>OR</code> ，该操作可以仅将第 0 位改变成 <code>1</code> ，并保持其他位不变。</p>\n<p>还有一点需要注意的是， <code>OR</code>  操作不能直接对 <code>cr0</code>  寄存器进行操作，所以我们需要借助 <code>eax</code>  寄存器来作为桥梁，完成对 <code>cr0</code>  寄存器的赋值，代码是不是已经呼之欲出了？</p>\n<details class=\"info\"><summary>进入保护模式</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">eax</span>, <span class=\"token register variable\">cr0</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>or <span class=\"token register variable\">eax</span>, <span class=\"token number\">0x1</span> <span class=\"token comment\">; set 32-bit mode bit in cr0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token register variable\">cr0</span>, <span class=\"token register variable\">eax</span></pre></td></tr></table></figure></div></details>\n<p>此时，我们就正式进入保护模式了。</p>\n<h3 id=\"刷新cpu管道\"><a class=\"anchor\" href=\"#刷新cpu管道\">#</a> 刷新 CPU 管道</h3>\n<p>为什么要刷新 CPU 管道（pipeline）呢？是因为 CPU 是以 pipeline 的方式工作的，需要执行的指令都在 pipeline 中，若两个不同指令依赖同一块数据，同时修改这块数据就可能导致危险，这种情况下，就需要刷新 CPU 管道来防止这种危险发生（这里查到的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS9qYXJnb24vcC9waXBlbGluZS1mbHVzaC5odG0jOn46dGV4dD1BJTIwaGF6YXJkJTIwY29uZGl0aW9uJTIwbWF5JTIwcHJlc2VudCxjb3JydXB0ZWQlMjBieSUyMHRoZSUyMHBpcGVsaW5pbmclMjBwcm9jZXNzLg==\">资料</span>是这样的，但是感觉稍微有一点点问题，有熟悉的师傅欢迎评论区留言呀～）。</p>\n<p>刷新 CPU 管道也非常简单，可以通过一个远跳命令实现:</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>jmp CODE_SEG:init_pm <span class=\"token comment\">; far jump by using a different segment to refresh pipeline</span></pre></td></tr></table></figure><h3 id=\"初始化段寄存器\"><a class=\"anchor\" href=\"#初始化段寄存器\">#</a> 初始化段寄存器</h3>\n<p>上一章中我们已经介绍了寄存器的默认用法及含义，这里详细介绍下段寄存器各自的用途</p>\n<div class=\"note info no-icon\">\n<p>在保护模式下，CPU 提供了段寄存器（16 位）。段寄存器存放的并不是段的基地址，而是段选择符（Segment Descriptor）的相对于 GDT 地址的偏移地址（这也是为什么我们在上一节的代码中要定义 <code>CODE_SEG</code>  和 <code>DATA_SEG</code>  的原因），这些段寄存器包括 <code>cs</code> 、 <code>ss</code> 、 <code>ds</code> 、 <code>es</code> 、 <code>fs</code> 、 <code>gs</code> 。前三个寄存器有特定用途：</p>\n<ul>\n<li><strong>cs</strong>：代码段寄存器，指向包含程序指令的段</li>\n<li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段</li>\n<li><strong>ds</strong>：数据段寄存器，指向包含静态数据或全局数据的数据段</li>\n</ul>\n<p>后三个段寄存器是通用的。</p>\n</div>\n<p><code>cs</code>  寄存器直接由 CPU 设置（想想上一章中讲的）我们无需初始化，所以我们就需要初始化其他的寄存器，至于用什么初始化，当然是我们提前定义好的 <code>DATA_SEG</code>  变量啦，有一点需要注意，段寄存器同样也不能直接进行立即数的赋值，我们需要借助 <code>ax</code> （16 位）来帮助赋值。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">[</span>bits <span class=\"token number\">32</span><span class=\"token operator\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">init_pm:</span> <span class=\"token comment\">; we are now using 32-bit instructions</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    mov <span class=\"token register variable\">ax</span>, DATA_SEG <span class=\"token comment\">; update the segment registers</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mov <span class=\"token register variable\">ds</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">ss</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">es</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    mov <span class=\"token register variable\">fs</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    mov <span class=\"token register variable\">gs</span>, <span class=\"token register variable\">ax</span></pre></td></tr></table></figure><h3 id=\"初始化栈\"><a class=\"anchor\" href=\"#初始化栈\">#</a> 初始化栈</h3>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/k0xq4i.png\" alt=\"mbr工作阶段内存布局\" /></p>\n<p>还记得上面这个图吗，我们将 <code>loader</code>  的地址设置在了 <code>0x8000</code>  后 <code>0x1000</code>  的空间内，此时 <code>0x8000</code>  前后的空间和 <code>mbr</code>  前的空间都是空着的，我们用 <code>mbr</code>  前面的空间来布置栈，就像示意图中标识的那样，将栈底设置为 <code>0x7B00</code> （栈向低地址增长），代码同样非常简单。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ebp</span>, <span class=\"token number\">0x7B00</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">esp</span>, <span class=\"token register variable\">ebp</span></pre></td></tr></table></figure><p>将以上代码合并起来，就形成了从实模式到保护模式的代码</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">[</span>bits <span class=\"token number\">16</span><span class=\"token operator\">]</span> <span class=\"token comment\">; real mode</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">switch_to_pm:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    cli <span class=\"token comment\">; 1. disable interrupts</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    lgdt <span class=\"token operator\">[</span>gdt_descriptor<span class=\"token operator\">]</span> <span class=\"token comment\">; 2. load the GDT descriptor</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">eax</span>, <span class=\"token register variable\">cr0</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    or <span class=\"token register variable\">eax</span>, <span class=\"token number\">0x1</span> <span class=\"token comment\">; 3. set 32-bit mode bit in cr0</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    mov <span class=\"token register variable\">cr0</span>, <span class=\"token register variable\">eax</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    jmp CODE_SEG:init_pm <span class=\"token comment\">; 4. far jump by using a different segment to refresh cpu pipeline</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token operator\">[</span>bits <span class=\"token number\">32</span><span class=\"token operator\">]</span> <span class=\"token comment\">; protected mode</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token label function\">init_pm:</span> <span class=\"token comment\">; we are now using 32-bit instructions</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    mov <span class=\"token register variable\">ax</span>, DATA_SEG <span class=\"token comment\">; 5. update the segment registers</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    mov <span class=\"token register variable\">ds</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    mov <span class=\"token register variable\">ss</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    mov <span class=\"token register variable\">es</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    mov <span class=\"token register variable\">fs</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    mov <span class=\"token register variable\">gs</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    mov <span class=\"token register variable\">ebp</span>, <span class=\"token number\">0x7B00</span> <span class=\"token comment\">; 6. update the stack right at the top of the free space</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    mov <span class=\"token register variable\">esp</span>, <span class=\"token register variable\">ebp</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    call BEGIN_PM <span class=\"token comment\">; 7. Call a well-known label with useful code</span></pre></td></tr></table></figure><p>此时，我们不妨写一个 main 函数来调用上述过程，然后测试一下程序：</p>\n<pre><code class=\"language-nasm\"></code></pre>\n<hr />\n<p>至此，CPU 已经进入了保护模式（32 位），接下来我们需要完成虚拟内存到物理内存的映射，为 kernel 的工作打下基础，由于这部分内容体量相对庞大且至关重要，所以我们放在下一章详细去讲。</p>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/02-mbr/",
            "url": "https://gality.cn/os/02-mbr/",
            "title": "02-从BIOS启动到MBR编写",
            "date_published": "2023-08-22T04:03:46.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第三篇文章，主要讲解了计算机从通电到启动操作系统前的过程。在本章中，我将会介绍引导启动中的核心概念和知识，并最终自己实现一个 MBR。</p>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: assembler, BIOS, BOOT, Real mode, interrupts, CPU registers, control structures, function calling, strings</em></p>\n</div>\n<h1 id=\"bios和boot\"><a class=\"anchor\" href=\"#bios和boot\">#</a> BIOS 和 BOOT</h1>\n<p>即使不了解计算机的人也可能对于 <code>boot</code>  和 <code>bios</code>  这两个词有所耳闻，然而即使是计算机专业的人也可能会混淆这两者的概念，这里我们先来区分一下这两个概念，以便于我们后续的展开。</p>\n<ul>\n<li><ins class=\"wavy\">BIOS</ins> 是英文 &quot;Basic Input Output System&quot; 的缩略语，直译过来后中文名称就是 &quot;基本输入输出系统&quot;。它是一组固化到计算机内主板上一个<strong> ROM 芯片</strong>上的程序，由主板的制造厂商编写代码；我们有时听到的 “刷 BIOS” 就是指将主版上的 BIOS 程序进行更换。</li>\n<li><ins class=\"wavy\">BOOT</ins> 其实是指 <code>Boot Loader</code> ，boot 本身就是 “引导” 的意思，是指一种用来引导操作系统激活的程序，广泛应用于各种系统之中。</li>\n</ul>\n<h2 id=\"对比\"><a class=\"anchor\" href=\"#对比\">#</a> 对比</h2>\n<p>BIOS 保存着计算机最重要的<strong>基本输入输出程序</strong>、<strong>系统设置信息</strong>、<strong>开机后自检程序</strong>和<strong>系统自启动程序</strong>，其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。可从 CMOS 中读写系统设置的具体信息。</p>\n<p>当按下电脑开机键的一瞬间，CPU 会先被激活去寻找 BIOS，接着 BIOS 会先在 Flash Memory 中执行，初始化计算机各种硬件并检测完整性，再执行 CMOS 中用户所喜好的设置，然后 BIOS 将自己解压缩到计算机的主存储器中。再启动引导程序 boot，然后由 boot 将操作系统加载到内存中执行。</p>\n<p>Boot 的过程其实就是由 <code>mbr</code> + <code>loader</code>  一起实现的，后面会详细讲解什么是 <code>mbr</code> ，什么是 <code>loader</code> ，耐心看下去吧～</p>\n<h1 id=\"mbr实现\"><a class=\"anchor\" href=\"#mbr实现\">#</a> MBR 实现</h1>\n<p>尽管很多教程中直接提供了 <code>mbr</code>  和 <code>loader</code>  供我们使用而无需自己编写，但是我仍推荐至少自行实现一次这两者，原因如下；</p>\n<ul>\n<li>有助于提高汇编能力，这一点在后面也至关重要。</li>\n<li>它的编写并不困难，可以借助 <code>mbr</code> +  <code>loader</code>  的编写来入门操作系统的编写。</li>\n<li>从 CPU 通电开始写起有助于建立对于计算机的全面认知，为后面的内核、可执行程序的加载，以及虚拟内存的建立做好准备。</li>\n<li>boot 阶段会初步搭建起 segment 以及虚拟内存的框架，为后续 kernel 编写打下基础</li>\n</ul>\n<p>💗真是激动人心，我们要开始编写自己的 <code>mbr</code>  了！</p>\n<h2 id=\"从通电开始\"><a class=\"anchor\" href=\"#从通电开始\">#</a> 从通电开始</h2>\n<p>一个经典的问题：<span class=\"orange\">计算机通电后是怎么就进入到了操作系统呢？</span></p>\n<p>计算机通电后，CPU 处于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlOUUlRTYlQTglQTElRTUlQkMlOEYvNzM1NDUzMQ==\">实模式</span>，在实模式下，CPU 寻址方式为：由 16 位段寄存器值 * 10H 加 16 位偏移地址来形成 20 位的寻址空间，即只有 1M 的空间是可以被 CPU 读取的，而其他空间 CPU 都无法使用，CPU 必须借助这 1M 空间内的存储的各种程序来引导操作系统启动。</p>\n<details class=\"primary\"><summary>为什么是20位寻址空间呢？</summary><div>\n<p>这与 CPU 的发展历史有关，在 CPU 早期 (8086 时期)，由于 CPU 性能有限，一共只有 20 位地址线，可寻址空间只有 1M (2<sup>20</sup> bytes)，以及 8 个 16 位的通用寄存器，和 4 个 16 位的段寄存器；16 位的物理地址只能访问 64KB (2<sup>16</sup> bytes) 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的寻址地址，访问 1 MB 的内存，必须采取一种特殊的方式。</p>\n<p>特殊方式即由 <code> 段基址 + 段内偏移</code> 的方式来将 16 位的地址扩展为 20 位，具体方式如下：</p>\n<ul>\n<li>段基址：由段寄存器提供，并将寄存器值左移 4 位，将结果作为基地址。</li>\n<li>段内偏移地址：由通用寄存器来提供 (如 EIP)</li>\n</ul>\n<p>将二者相加，得到一个 20 位的地址，覆盖 CPU 20 位的寻址空间，这里给出一个例子以便于更形象的说明：</p>\n<p>例如，段基址为 <code>0x1000</code> ，段内偏移为 <code>0x1234</code> ，则此时物理地址可以由下式计算得出：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.15999999999999992em\" columnalign=\"center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mn>0</mn><mi>x</mi><mn>1000</mn><mo>&lt;</mo><mo>&lt;</mo><mn>4</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>10000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>11234</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin {array}{c}\n\n0x1000 &lt;&lt; 4 + 0x1234 = 0x10000 + 0x1234 = 0x11234\n\n\\end {array}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2000000000000002em;vertical-align:-0.35000000000000003em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8500000000000001em;\"><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">1</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35000000000000003em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span></span></span></span></span></span></span></p>\n</div></details>\n<p>因此，这至关重要的 1MB 空间的划分是已经固定好的，每一块都有规定的用途的，被映射到不同的设备上：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/vj8uwa.png\" alt=\"实模式下1M寻址空间分配表\" /></p>\n<h2 id=\"bios的工作\"><a class=\"anchor\" href=\"#bios的工作\">#</a> BIOS 的工作</h2>\n<p>我们前面提到，CPU 通电后，将会执行 BIOS 程序，那么 BIOS 具体的工作有哪些呢？包括以下几步：</p>\n<ol>\n<li>开机后 CPU 的指令寄存器 \t <code>EIP</code>  被设置为地址  <code>0xFFFF0</code> ，这一地址指向 BIOS 固件上的代码，CPU 从这里执行开机后的第一条指令；</li>\n<li>CPU 开始执行 BIOS 上的代码，这一部分主要是硬件输入输出设备相关的检查，以及建立一个最初的中断向量表（后面会提到）；</li>\n<li>BIOS 代码最后阶段的工作，就是检查启动盘上的  <code>mbr</code>  分区，所谓 mbr 分区就是指磁盘上的第一个 512 bytes 的内容，又叫 <code>引导分区</code> ；BIOS 会对这 512 bytes 做一个检查：它的最后 2 个字节必须是特定的两个 magic number： <code>0x55</code>  和  <code>0xaa</code> ，否则它就不是一个合法的启动盘；</li>\n<li>检查通过后，BIOS 将这 512B 加载到内存  <code>0x7C00</code>  处，到 0x7E00 为止，然后指令跳转到 0x7C00 开始执行；至此 BIOS 退出舞台；</li>\n</ol>\n<p>我们可以将这个过程画成一个图，来帮助我们理解</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/a4r89b.png\" alt=\"\" /></p>\n<ul>\n<li>黄色部分是 <code>mbr</code> ，被 bios 从磁盘复制到内存中去执行</li>\n<li>粉色部分是 <code>bios</code>  代码</li>\n<li>黄色部分的两边的白色部分 (0x500 开始) 是我们可以自由使用的空间</li>\n</ul>\n<h2 id=\"mbr的工作\"><a class=\"anchor\" href=\"#mbr的工作\">#</a> mbr 的工作</h2>\n<p><code>mbr</code>  的大小被限制在了 512 bytes，这对于引导一个操作系统的重任来说有点太小了，里面根本放不下太多的数据和代码，所以 <code>mbr</code>  的工作其实只是将一个 <code>laoder</code>  加载到内存，然后跳转到 <code>loader</code>  去继续执行。</p>\n<p>我们还是用一个示意图来表示这个过程的变化和内存布局：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/k0xq4i.png\" alt=\"mbr工作阶段内存布局\" /></p>\n<p>「假设我们把 <code>loader</code>  加载到 <code>0x8000</code>  处（可以任意指定加载的位置，只需要 <code>mbr</code>  中对应起来就可以）， <code>loader</code>  大约 4KB 大小」</p>\n<p>上一节中我们说过， <code>mbr</code>  被加载到内存后，前后都有一块可供我们自由使用的空间，前面那块 (0x500 开始) 较小，大约 30KB，而后面这块 (0x7E00 开始) 就大的多了，大约有 608KB 左右的空间，我们就可以利用这块内存空间，将 <code>loader</code>  加载进内存并执行。</p>\n<h2 id=\"牛刀小试\"><a class=\"anchor\" href=\"#牛刀小试\">#</a> 牛刀小试</h2>\n<p>理论知识已经学了很多了，但是直接就开始写一个完整 <code>mbr</code>  还是有点难度的，不如我们从 <code>hello world</code>  开始。</p>\n<div class=\"note default\">\n<p>🎯编写一个 mbr，并打印 'Hello World!'</p>\n</div>\n<p>原理：通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSU5UXzEwSA==\"> 0x10H 中断</span>触发 bios 中的打印服务，向屏幕输出字符，该中断的调用规则为：</p>\n<table>\n<thead>\n<tr>\n<th>Teletype output</th>\n<th>AH=0Eh</th>\n<th>AL = Character, BH = Page Number, BL = <span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQklPU19Db2xvcl9BdHRyaWJ1dGVz\">Color</span> (only in graphic mode)</th>\n<th>no return</th>\n</tr>\n</thead>\n</table>\n<p>然后我们就可以编写代码了：</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span> <span class=\"token comment\">; set tty mode</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'H'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'e'</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'l'</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>int <span class=\"token number\">0x10</span> <span class=\"token comment\">; 'l' is still on al</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'o'</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">' '</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'W'</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'o'</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'r'</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'l'</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'d'</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>mov <span class=\"token register variable\">al</span>, <span class=\"token string\">'!'</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>jmp <span class=\"token operator\">$</span><span class=\"token comment\">;  jump to current address = infinite loop</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>times <span class=\"token number\">510</span> <span class=\"token operator\">-</span> (<span class=\"token operator\">$</span><span class=\"token operator\">-</span><span class=\"token operator\">$</span><span class=\"token operator\">$</span>) db <span class=\"token number\">0</span> <span class=\"token comment\">; fill with 0,length = (510 - previous code)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>dw <span class=\"token number\">0xaa55</span> <span class=\"token comment\">; x86 is little-endian</span></pre></td></tr></table></figure><div class=\"note info no-icon\">\n<p>nasm 语法：</p>\n<ul>\n<li><code>$</code> ：当前行在所在段的相对位移</li>\n<li><code>$$</code> ：当前段的起始地址</li>\n<li><code>dd</code> ：即  <code>define double</code> ，定义一个 4 字节值</li>\n<li><code>dw</code> ：即 <code>define word</code> ，定义一个 2 字节值</li>\n<li><code>db</code> ：即  <code>define byte</code> ，定义一个 1 字节值</li>\n</ul>\n</div>\n<p>我们把上面的代码保存成  <code>boot_hello_world.asm</code> , 然后用 <code>nasm</code>  编译他：</p>\n<p><code>nasm -fbin boot_hello_world.asm -o boot_hello_world.bin</code></p>\n<p>然后你就可以通过 <code>xxd</code>  来查看生成的 <code>bin</code>  文件:</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/szjute.jpg\" alt=\"xxd of bin file\" /></p>\n<p>我们可以看到，结尾时 Magic Number  <code>0x55aa</code> ，前面是我们写的 asm 代码转成的机器码，中间用 0 填充，一共 <code>0x200</code>  也就是 512bytes。</p>\n<p>接着就可以用 qemu 来执行他了</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>qemu-system-x86_64 boot_hello_world.bin</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>qemu boot_hello_world.bin</pre></td></tr></table></figure><p>不出意外的话，你就会看到 <code>Hello World!</code>  了🎉</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/q8kecc.png\" alt=\"qemu with hello world\" /></p>\n<h3 id=\"problem-time\"><a class=\"anchor\" href=\"#problem-time\">#</a> Problem Time</h3>\n<ol>\n<li class=\"quiz\">\n<p>以下哪行代码可以使 <code>Hello World!</code>  以绿色字体输出：</p>\n<ul class=\"options\">\n<li><code>mov bl, 0x0a</code></li>\n<li><code>mov bh, 0x0a</code></li>\n<li><code>mov bl, 0x0c</code></li>\n<li class=\"correct\">以上都不对</li>\n</ul>\n<blockquote>\n<ul class=\"options\">\n<li>该设置只有在图形化模式下才生效</li>\n<li>需设置 bl 才能影响输出字符颜色</li>\n<li>根据手册 10 才是绿色对应的代码</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"更进一步打印信息\"><a class=\"anchor\" href=\"#更进一步打印信息\">#</a> 更进一步 (打印信息)</h2>\n<p>上面我们已经学会了打印字符，那么接下来我们尝试编写几个打印函数用于输出错误或信息，帮助我们在后面的过程中定位问题。</p>\n<h3 id=\"打印新行\"><a class=\"anchor\" href=\"#打印新行\">#</a> 打印新行</h3>\n<p>先简单一点，我们写一个打印换行符的函数 <code>print_nl()</code> ，其实就是依次打印 ascii 表特殊字符中的换行符，很简单，做一点点解释</p>\n<ul>\n<li>\n<p><code>\\r</code> ：对应 ascii 码为 13 的字符，表示回车，将当前位置移到本行头</p>\n</li>\n<li>\n<p><code>\\n</code> ：对应 ascii 码为 10 的字符，表示换行，将当前位置移动到下一行</p>\n</li>\n</ul>\n<details class=\"info\"><summary>print_nl()</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; print a new line</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">print_nl:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span> <span class=\"token comment\">; tty mode</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token number\">0x0a</span> <span class=\"token comment\">; '\\r'</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token number\">0x0d</span> <span class=\"token comment\">; '\\n'</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    int <span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    ret</pre></td></tr></table></figure></div></details>\n<h3 id=\"打印字符串\"><a class=\"anchor\" href=\"#打印字符串\">#</a> 打印字符串</h3>\n<p>然后加大一点难度，通过循环来实现一个打印字符串的函数 <code>print()</code> ，本质就是一个一个的打印字符，一些要点如下：</p>\n<ul>\n<li>因为调用 <code>print()</code>  的场景是程序运行过程中，所以函数开始要 <code>pusha</code>  保存 “现场”，在调用结束前还需要用 <code>popa</code>  还原 “现场”</li>\n<li>通过 <code>bx</code>  寄存器来传递参数 (寄存器有<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL2Fzc2VtYmx5X3Byb2dyYW1taW5nL2Fzc2VtYmx5X3JlZ2lzdGVycy5odG0=\">默认的用法</span>，这里推荐用 <code>bx</code>  来传递参数)</li>\n<li>可以通过 <code>cmp</code>  和 <code>je</code>  命令来进行条件判断和分支跳转。</li>\n</ul>\n<details class=\"info\"><summary>print( [bx]string s )</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; print a string pointed with bx</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">print:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">; keep this in mind:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">; while (string[i] != 0) &#123; print string[i]; i++ &#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">; the comparison for string end (null byte)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token label function\">print_start:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    mov <span class=\"token register variable\">al</span>, <span class=\"token operator\">[</span><span class=\"token register variable\">bx</span><span class=\"token operator\">]</span> <span class=\"token comment\">; 'bx' is the base address for the string</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; if '\\0', then stop loop</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    je print_end</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">; the part where we print with the BIOS help</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    mov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x0e</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    int <span class=\"token number\">0x10</span> <span class=\"token comment\">; 'al' already contains the char</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">; increment pointer and do next loop</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    add <span class=\"token register variable\">bx</span>, <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    jmp print_start</pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token label function\">print_end:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    ret</pre></td></tr></table></figure></div></details>\n<h3 id=\"以十六进制打印数字\"><a class=\"anchor\" href=\"#以十六进制打印数字\">#</a> 以十六进制打印数字</h3>\n<p>同样的道理，我们来将数字以 16 进制打印出来，由于我们直接是直接对接底层 CPU 的处理，没有现成的进制转换函数供我们使用，此时我们需要自己处理进制转换（数字到字符）和格式化输出，步骤如下：</p>\n<ol>\n<li>参数：通过 <code>dx</code>  寄存器来传递参数</li>\n<li>预处理：用寄存器来记录需要被转换的值，寄存器为 16 位，每次处理 4 位（一个 16 进制字符），所以要建立一个循环 4 次的函数</li>\n<li>取数字：可以通过和 <code>0x000f</code>  进行 <code>与操作</code> 的方式，来仅取出 4 位数，方便后续处理</li>\n<li>进制转换：原数字 + <code>0x30</code>  就会转换成对应的数字的字符，与 9 做比较，如果更大，就加 7（对应 ascii 表的 <code>A</code> -&gt; <code>F</code> ）</li>\n<li>格式化处理：结合索引，通过移位的方式来将字符放在合适的位置，</li>\n<li>打印：调用上面写的 <code>print()</code>  函数</li>\n</ol>\n<p><span class=\"wavy\">注意</span>：字符串在定义时末尾必须加上 <code>0</code> ，来作为字符串结束的标识（例如 <code>HEX_OUT</code> ）</p>\n<details class=\"info\"><summary>print_hex( [dx]number n )</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; receiving the data in 'dx'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">; For the examples we'll assume that we're called with dx=0x1234</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token label function\">print_hex:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    pusha</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">cx</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; our index variable</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">; Strategy: get the last char of 'dx', then convert to ASCII</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">; Numeric ASCII values: '0' (ASCII 0x30) to '9' (0x39), so just add 0x30 to byte N.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">; For alphabetic characters A-F: 'A' (ASCII 0x41) to 'F' (0x46) we'll add 0x40</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">; Then, move the ASCII byte to the correct position on the resulting string  </span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token label function\">print_hex_start:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    cmp <span class=\"token register variable\">cx</span>, <span class=\"token number\">4</span> <span class=\"token comment\">; loop 4 times</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    je print_hex_end</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">; 1. convert last char of 'dx' to ascii</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    mov <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">dx</span> <span class=\"token comment\">; we will use 'ax' as our working register</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    and <span class=\"token register variable\">ax</span>, <span class=\"token number\">0x000f</span> <span class=\"token comment\">; 0x1234 -> 0x0004 by masking first three to zeros</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    add <span class=\"token register variable\">al</span>, <span class=\"token number\">0x30</span> <span class=\"token comment\">; add 0x30 to N to convert it to ASCII \"N\"</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token number\">0x39</span> <span class=\"token comment\">; if > 9, add extra 8 to represent 'A' to 'F'</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    jle step2</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    add <span class=\"token register variable\">al</span>, <span class=\"token number\">0x07</span> <span class=\"token comment\">; 'A' is ASCII 65 instead of 58, so 65-58=7</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token label function\">step2:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token comment\">; 2. get the correct position of the string to place our ASCII char</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">; bx &lt;- base address + string length - index of char</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, hex_string <span class=\"token operator\">+</span> <span class=\"token number\">5</span> <span class=\"token comment\">; base + length</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    sub <span class=\"token register variable\">bx</span>, <span class=\"token register variable\">cx</span> <span class=\"token comment\">; our index variable</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    mov <span class=\"token operator\">[</span><span class=\"token register variable\">bx</span><span class=\"token operator\">]</span>, <span class=\"token register variable\">al</span> <span class=\"token comment\">; copy the ASCII char on 'al' to the position pointed by 'bx'</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    ror <span class=\"token register variable\">dx</span>, <span class=\"token number\">4</span> <span class=\"token comment\">; 0x1234 -> 0x4123 -> 0x3412 -> 0x2341 -> 0x1234</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">; increment index and loop</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    add <span class=\"token register variable\">cx</span>, <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    jmp print_hex_start</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token label function\">print_hex_end:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token comment\">; prepare the parameter and call the function</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token comment\">; remember that print receives parameters in 'bx'</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, hex_string</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    ret</pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token label function\">hex_string:</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    db <span class=\"token string\">'0x0000'</span>, <span class=\"token number\">0</span> <span class=\"token comment\">; reserve memory for our new string</span></pre></td></tr></table></figure></div></details>\n<p>完成以上打印函数后，我们可以将他们保存在 <code>print.nasm</code>  中，然后通过 <code>%include &quot;boot_print.asm&quot;</code>  的方式在别的 <code>asm</code>  中使用我们定义好的打印函数</p>\n<h2 id=\"一步登天\"><a class=\"anchor\" href=\"#一步登天\">#</a> 一步登天</h2>\n<p><s class=\"danger\">好了，现在你已经学会 1+1 了，现在请计算 9.121*7.32/6.97 吧</s></p>\n<p>根据我们之前说的，仔细想想，编写的 <code>mbr\t</code> 的功能，拆解一下其实并不复杂，本质就是读取一块硬盘，并将 <code>loader</code>  加载到内存中，然后跳转到 <code>loader</code>  执行就可以了，稍微复杂的点在于，由于历史原因，读磁盘时采用的是 CHS 的模式，这点也你会在后面更近一步学习，接着往下看吧。</p>\n<p>「以下代码的部分希望读者能自己根据原理完成，如果觉得较为困难，可以打开折叠栏查看」</p>\n<h3 id=\"nasm读硬盘\"><a class=\"anchor\" href=\"#nasm读硬盘\">#</a> nasm 读硬盘</h3>\n<p>好消息是我们无需去直接跟磁盘打交道，bios 中同样写好了读写磁盘的程序，我们只需要跟打印程序一样通过中断来调用即可。我么可以通过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFuaXNsYXZzLm9yZy9oZWxwcGMvaW50XzEzLTIuaHRtbA==\"> 0x13H 中断</span>来读写磁盘，该中断的调用参数为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AH</td>\n<td style=\"text-align:center\">02H =&gt; bios 磁盘服务程序中的读磁盘程序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">要读的扇区个数\t(1-128 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CH</td>\n<td style=\"text-align:center\">磁道号的低 8 位  (0-1023 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CL</td>\n<td style=\"text-align:center\">低 5 位为所读起始扇区号， 6-7 位表示磁道号的高 2 位 (1-17 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DH</td>\n<td style=\"text-align:center\">所读磁盘的磁头号  (0-15 dec.)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DL</td>\n<td style=\"text-align:center\">需要进行读操作的驱动器号 (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ES:BX</td>\n<td style=\"text-align:center\">缓冲区地址</td>\n</tr>\n</tbody>\n</table>\n<p>返回值为：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AH</td>\n<td style=\"text-align:center\">status  (see INT 13,STATUS)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">number of sectors read</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CF</td>\n<td style=\"text-align:center\">0 = successful OR 1 = error</td>\n</tr>\n</tbody>\n</table>\n<p>在 mbr 启动的时候，CPU 处于实模式，此时只能使用 bios 按 CHS 的寻址方式来找到 <code>loader</code>  的位置。</p>\n<details class=\"primary\"><summary>CHS到底是什么呢？</summary><div>\n<p>CHS 即 (Cylinder/Head/Sector)，是非常古老的硬盘参数了，很久以前，硬盘的容量还很小，人们采用类似软盘的结构生产硬盘，即硬盘盘片的每一条磁道都具有相同的扇区数，由此产生了磁头数 (Heads)，柱面数 (Cylinders)，扇区数 (Sectors) 以及相应的寻址方式.</p>\n<p>其中:</p>\n<ul>\n<li>磁头数 (Heads)：表示硬盘总共有几个磁头，也就是有几面盘片，最大为 255  (用 8 个二进制位存储);</li>\n<li>柱面数 (Cylinders)：表示硬盘每一面盘片上有几条磁道，最大为 1023 (用 10 个二进制位存储) =&gt; 每条磁道都有编号，叫做磁道号；</li>\n<li>扇区数 (Sectors)：表示每一条磁道上有几个扇区，最大为  63  (用 6  个二进制位存储).</li>\n</ul>\n<p>每个扇区一般是  512 个字节，理论上讲这不是必须的，但好象没有取别的值的。</p>\n<p>因此，数据寻址方式为：先找到磁头，然后再通过柱面和扇区来确定唯一一个磁道，磁道中记录了数据。（如果你想了解<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3lsaW5kZXItaGVhZC1zZWN0b3I=\">更多有关早期硬盘的知识</span>）</p>\n</div></details>\n<h4 id=\"参数值讲解\"><a class=\"anchor\" href=\"#参数值讲解\">#</a> 参数值讲解</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Register</th>\n<th style=\"text-align:center\">Value</th>\n<th style=\"text-align:center\">Remark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">AL</td>\n<td style=\"text-align:center\">0x02</td>\n<td style=\"text-align:center\">要读两个扇区 (根据实际情况)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CH</td>\n<td style=\"text-align:center\">0x0</td>\n<td style=\"text-align:center\">仍然是 0 号磁道，只不过是去读第二个扇区)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CL</td>\n<td style=\"text-align:center\">0x02</td>\n<td style=\"text-align:center\"><code>mbr</code>  总是在 <code>fisrt of cylinder 0 of head 0 of hdd 0 </code> ，因此任何字节都只能在第二个扇区之后</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DH</td>\n<td style=\"text-align:center\">0x00</td>\n<td style=\"text-align:center\">读取第一个磁头 (即第一个盘片)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DL</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">由 bios 自动设置</td>\n</tr>\n</tbody>\n</table>\n<p>我们这里先将读磁盘内容的命令封装成一个函数，同时增加一点错误输出函数来帮助我们定位可能存在的错误</p>\n<details class=\"info\"><summary>disk_load([dh]sector n)</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">; load 'dh' sectors from drive 'dl' into ES:BX</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token label function\">disk_load:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\tpusha</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\tpush <span class=\"token register variable\">dx</span> <span class=\"token comment\">; store the argument in 'dh'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\tmov <span class=\"token register variable\">ah</span>, <span class=\"token number\">0x02</span> <span class=\"token comment\">; 0x02 = 'read disk'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\tmov <span class=\"token register variable\">al</span>, <span class=\"token register variable\">dh</span> <span class=\"token comment\">; al &lt;- number of sectors to read (0x01 .. 0x80)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\tmov <span class=\"token register variable\">cl</span>, <span class=\"token number\">0x02</span> <span class=\"token comment\">; cl &lt;- sector (0x01 .. 0x11)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\tmov <span class=\"token register variable\">ch</span>, <span class=\"token number\">0x00</span> <span class=\"token comment\">; ch &lt;- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\tmov <span class=\"token register variable\">dh</span>, <span class=\"token number\">0x00</span> <span class=\"token comment\">; dh &lt;- head number (0x0 .. 0xF)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token comment\">; [es:bx] &lt;- pointer to buffer where the data will be stored</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">; caller sets it up for us, and it is actually the standard location for int 13h</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    int <span class=\"token number\">0x13</span>      <span class=\"token comment\">; BIOS interrupt</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    jc disk_error <span class=\"token comment\">; if error (stored in the carry bit)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    pop <span class=\"token register variable\">dx</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    cmp <span class=\"token register variable\">al</span>, <span class=\"token register variable\">dh</span>    <span class=\"token comment\">; BIOS also sets 'al' to the # of sectors read. Compare it.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    jne sectors_error</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    popa</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    ret</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token label function\">disk_error:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, DISK_ERROR</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    mov <span class=\"token register variable\">dh</span>, <span class=\"token register variable\">ah</span> <span class=\"token comment\">; ah = error code, dl = disk drive that dropped the error</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    call print_hex <span class=\"token comment\">; check out the code at http://stanislavs.org/helppc/int_13-1.html</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    jmp disk_loop</pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token label function\">sectors_error:</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, SECTORS_ERROR</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    call print</pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token label function\">disk_loop:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    jmp <span class=\"token operator\">$</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token label function\">DISK_ERROR:</span> db <span class=\"token string\">\"Disk read error\"</span>, <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token label function\">SECTORS_ERROR:</span> db <span class=\"token string\">\"Incorrect number of sectors read\"</span>, <span class=\"token number\">0</span></pre></td></tr></table></figure></div></details>\n<p>此时还没有结束，让我们写一个 <code>main</code>  函数在将所有之前写的功能串联起来吧，注意这里还有如下几点需要注意：</p>\n<ul>\n<li>开头要加上 <code>[org 0x7c00]</code> ，该命令会将后续出现的所有地址在寻址时加上该偏移，因为这里才是 <code>mbr</code>  真实执行的地址，也即我们各种数据储存的 “基地址”，如果不加的话，在寻址时会出现错误。</li>\n<li>在安全的位置设置我们自己的堆栈</li>\n<li>记得要设置 <code>bx</code>  寄存器指向 <code>loader</code>  的加载地址（因为 <code>es:bx</code>  指向读取出的硬盘数据的存储位置）</li>\n<li>由于我们还没有写 <code>loader</code> ，可以暂时先将 <code>sector 2</code>  设置成某特殊字符，来检验读取效果</li>\n</ul>\n<details class=\"info\"><summary>main.asm</summary><div>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">[</span>org <span class=\"token number\">0x7c00</span><span class=\"token operator\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    mov <span class=\"token register variable\">bp</span>, <span class=\"token number\">0x7B00</span> <span class=\"token comment\">; set the stack safely away from us</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    mov <span class=\"token register variable\">sp</span>, <span class=\"token register variable\">bp</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mov <span class=\"token register variable\">bx</span>, <span class=\"token number\">0x8000</span> <span class=\"token comment\">; es:bx = 0x0000:0x8000 = 0x08000</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mov <span class=\"token register variable\">dh</span>, <span class=\"token number\">2</span> <span class=\"token comment\">; read 2 sectors</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">; the bios sets 'dl' for our boot disk number</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">; if you have trouble, use the '-fda' flag: 'qemu -fda file.bin'</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    call disk_load</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    mov <span class=\"token register variable\">dx</span>, <span class=\"token operator\">[</span><span class=\"token number\">0x8000</span><span class=\"token operator\">]</span> <span class=\"token comment\">; retrieve the first loaded word, 0xdada</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    mov <span class=\"token register variable\">dx</span>, <span class=\"token operator\">[</span><span class=\"token number\">0x8000</span> <span class=\"token operator\">+</span> <span class=\"token number\">512</span><span class=\"token operator\">]</span> <span class=\"token comment\">; first word from second loaded sector, 0xface</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    jmp <span class=\"token operator\">$</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token operator\">%</span>include <span class=\"token string\">\"boot_print.asm\"</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token operator\">%</span>include <span class=\"token string\">\"boot_sect_disk.asm\"</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\">; Magic number</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>times <span class=\"token number\">510</span> <span class=\"token operator\">-</span> (<span class=\"token operator\">$</span><span class=\"token operator\">-</span><span class=\"token operator\">$</span><span class=\"token operator\">$</span>) db <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>dw <span class=\"token number\">0xaa55</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">; boot sector = sector 1 of cyl 0 of head 0 of hdd 0</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token comment\">; from now on = sector 2 ...</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>times <span class=\"token number\">256</span> dw <span class=\"token number\">0xdada</span> <span class=\"token comment\">; sector 2 = 512 bytes</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>times <span class=\"token number\">256</span> dw <span class=\"token number\">0xface</span> <span class=\"token comment\">; sector 3 = 512 bytes</span></pre></td></tr></table></figure></div></details>\n<p>🎉以上就是本章的全部内容，下一章将会继续讲解 <code>loader</code>  的实现～</p>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/01-environment/",
            "url": "https://gality.cn/os/01-environment/",
            "title": "01-环境准备",
            "date_published": "2023-08-21T02:26:23.000Z",
            "content_html": "<div class=\"note info no-icon\">\n<p>本文章中的所有实践均推荐在 Linux 环境下进行，原因在于 Linux 可以自动处理依赖关系，便捷的完成依赖工具的构建，由于博主主力电脑为 Mac，所以实践环境为 MacOS，但是大体与 Linux 没有区别，以下为默认使用的环境：</p>\n<ul>\n<li>macOS Ventura 13.4.1 (c) - 英特尔芯片</li>\n<li>qemu  8.0.4</li>\n<li>nasm 2.16.01</li>\n</ul>\n</div>\n<div class=\"note warning\">\n<p><em>Concepts you may want to Google beforehand: linux, mac, terminal, compiler, emulator, nasm, qemu</em></p>\n</div>\n<h1 id=\"qemu\"><a class=\"anchor\" href=\"#qemu\">#</a> QEMU</h1>\n<p><ins class=\"wavy\">QEMU</ins>(<strong>Q</strong>uick <strong>Emu</strong>lator) 是一款免费且开源的模拟器，他通过动态二进制转换来模拟 CPU，并且提供了一组硬件和设备模型，使他能够运行多种原始操作系统；它还可以通过与 KVM 交互来以接近原生的速度运行虚拟机器。QEMU 同样可以模拟用户态进程，允许应用编译为另外一种架构的应用去运行（<s>人话版本：qemu 就是一个硬件模拟器，用来模拟计算机硬件</s>）。</p>\n<p>许多从零开始写操作系统的教程均是采用 Bochs 来作为模拟器，qemu 与其相比来说，不仅更加快速，而且提供了更多的调试手段，更加灵活，所以我们选择 qemu 来做硬件模拟。</p>\n<h2 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h2>\n<p>linux 系统下可以方便的安装 qemu，而 mac 则需要通过 <code>homebrew</code>  进行安装</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brew <span class=\"token function\">install</span> qemu</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> qemu</pre></td></tr></table></figure><p>对于 linux 来说，qemu 是以一个整体存在的，也直接通过 <code>qemu</code>  命令运行 <code>qemu</code> ，而对于 mac 来说，qemu 会被拆分为多个部分，可以通过补全来看到所有部分：</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/4c7nqq.png\" alt=\"\" /></p>\n<p>当安装完成后，我们可以通过 <code>qemu-system-x86_64</code>  来运行一个 qemu 虚拟机，如果此时你看到了这样一个黑框，那么恭喜你，qemu 就安装完成了。</p>\n<p><img data-src=\"http://imgcdn.gality.cn/blog/9qwzxs.png\" alt=\"\" /></p>\n<h1 id=\"nasm\"><a class=\"anchor\" href=\"#nasm\">#</a> NASM</h1>\n<p><ins class=\"wavy\">NASM</ins>(<strong>N</strong>etwide <strong>As</strong>se<strong>m</strong>bler ) 是一个汇编器和反汇编器，支持 x86 和 x64，被设计的非常便携和模块化。它支持多种文件类型，包括 Linux and *BSD  <code>a.out</code> , ELF, Mach-O, 16-bit and 32-bit  <code>.obj</code>  (OMF) format, COFF (including its Win32 and Win64 variants.) ；还可以输出纯二进制文件，intel hex 和 Motorola S-Record 格式。他的语法被设计的极其简单且易于理解，有点类似于<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaW50ZWwuY29tL2NvbnRlbnQvd3d3L3VzL2VuL2RldmVsb3Blci9hcnRpY2xlcy90ZWNobmljYWwvaW50ZWwtc2RtLmh0bWw=\">英特尔软件开发者手册</span>中的语法但稍微复杂一点；他支持当前所有已知的 x86 架构。</p>\n<h2 id=\"安装-2\"><a class=\"anchor\" href=\"#安装-2\">#</a> 安装</h2>\n<div class=\"note warning\">\n<p>强烈建议通过 homebrew 完整安装，尽管 mac 中 Xcode 其实内置了 nasm，但功能有所阉割，可能会在后续过程导致未知错误。</p>\n</div>\n<p>nasm 的安装也非常简单，可以直接命令安装</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># mac</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>brew <span class=\"token function\">install</span> nasm</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> nasm</pre></td></tr></table></figure><p>当你使用 <code>nasm -h</code>  成功打印出帮助信息时，则代表安装完成了。</p>\n<hr />\n<p>以上就是我们在后面会用到的所有工具了，qemu 主要负责模拟一个硬件环境给我们写的操作系统去运行，而 nasm 则是帮助我们去将我们写的代码转换成机器码去给硬件执行，通过这两个工具，我们就可以进行操作系统的编写了🎉🎉🎉</p>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功"
            ]
        },
        {
            "id": "https://gality.cn/os/00-preface/",
            "url": "https://gality.cn/os/00-preface/",
            "title": "序言-操作系统从0到1",
            "date_published": "2023-08-21T01:45:16.000Z",
            "content_html": "<div class=\"note info\">\n<p>本章是操作系统从 0 到 1 系列的第一篇文章，主要说明了本系列文章的目标、章节规划、前置知识储备及参考文章；文章编写力求图文丰富、逻辑完备，利用主线把知识串联起来，最终将从 0 到 1 实现一个操作系统所需要的知识都有机结合起来。</p>\n</div>\n<p>其实本科阶段在学习操作系统的时候就有跟着清华大学的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2tpdWtvdHN1L3Vjb3Jl\"> ucore 项目</span>，当时感觉学到了很多，但由于 ucore 是补充关键代码而非从真正意义上的 0 开始写一个操作系统，时至今日，细节已经完全模糊了，这是本系列产生的第一个原因。</p>\n<p>第二个原因也在于，之前在看 sakura 师傅的知乎问答时看到关于打基础的内容，提到了：&quot;自己写一个操作系统，并用自己的写的编译器来编译一个程序&quot;，又唤起了我之前的雄心，此时此刻，正适合有一个系列来记录这个过程，于是，<span class=\"rainbow\">Boooooom！</span></p>\n<h1 id=\"目标\"><a class=\"anchor\" href=\"#目标\">#</a> 目标</h1>\n<p>网上已经存在一些非常成熟的教程了，但可能或多或少都有一点点过时，软件版本的巨大变动使得过去教程中的一些东西可能有些过时（指的是工具部分，而非理论部分），这是我希望解决的第一个问题；同时我还希望能做到以下几点：</p>\n<ul>\n<li>\n<p>用丰富的图片去解析原理，用足够的资料去支撑理论。</p>\n</li>\n<li>\n<p>该系列将尽可能详细的对原理和实践进行解释，如果你仍然有疑问，欢迎评论，我会在看到后及时回复。</p>\n</li>\n<li>\n<p>最终实现一个微型操作系统，并在其上运行自己实现的编译器去编译运行一个程序。</p>\n</li>\n</ul>\n<h1 id=\"章节规划\"><a class=\"anchor\" href=\"#章节规划\">#</a> 章节规划</h1>\n<div class=\"note warning\">\n<p>非最终版，在系列结束后本部分会更新成确定版本</p>\n</div>\n<div class=\"note info\">\n<p>🎉🎉本系列的所有文章可以通过左手侧边栏中的系列文章索引进行快速到达～</p>\n</div>\n<ul>\n<li>序言</li>\n<li><a href=\"https://gality.cn/os/01-environment/\">环境准备</a></li>\n<li><a href=\"https://gality.cn/os/02-bios/\">BIOS 启动</a></li>\n<li>GDT 与保护模式</li>\n<li>虚拟内存实现</li>\n<li>加载并进入 kernel</li>\n<li>显示与打印</li>\n<li>全局描述符表 GDT</li>\n<li>中断处理</li>\n<li>虚拟内存完善</li>\n<li>实现堆和 malloc</li>\n<li>第一个 kernel 线程</li>\n<li>多线程切换</li>\n<li>锁于多线程同步</li>\n<li>进入用户态</li>\n<li>系统调用</li>\n<li>简单文件系统</li>\n<li>加载可执行文件</li>\n<li>键盘驱动</li>\n<li>运行 shell</li>\n</ul>\n<h1 id=\"前置知识储备\"><a class=\"anchor\" href=\"#前置知识储备\">#</a> 前置知识储备</h1>\n<p>操作系统本身就比较复杂，想自己实现操作系统并运行更需要很多其他的知识，这些知识中关于操作系统原理部分的知识会详细讲解，但涉及到工具的部分（模拟工具，编译工具等等）就不会过多的深入，只会讲一点于实现操作系统有关的部分，一切为主线服务。</p>\n<p>如果你已经具备以下知识，那么你可能可以较为轻松的接受本系列所讲知识，并将主要精力放在代码实践上，而如果你不是很了解以下知识，其实也没关系，不明白了就去搜索学习就好，带着问题学知识本身就是一种很好的学习方式，这些知识包括：</p>\n<ul>\n<li>C 语言能力</li>\n<li>一点 x86 汇编能力（可以在项目中提高）；</li>\n<li>熟练使用 Linux 系统，以及 Linux 下的系统编程经验；</li>\n<li>gcc，Makefile 等工具的使用；</li>\n<li>对编译，链接，执行代码的原理有足够的认识；</li>\n<li>硬件以及 OS 对内存的管理原理，尤其是虚拟内存；</li>\n<li>程序在操作系统中的加载，执行过程，内存的使用和分布；</li>\n<li>中断的概念和处理；</li>\n<li>进程，线程的概念及原理；</li>\n<li>多线程编程，同步与锁的概念；</li>\n</ul>\n<h1 id=\"参考文章\"><a class=\"anchor\" href=\"#参考文章\">#</a> 参考文章</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J1aWVycy9vcy10dXRvcmlhbC1jbi90cmVlL2NoaW5lc2U=\">https://github.com/ruiers/os-tutorial-cn/tree/chinese</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDA0MDEyNDY1MA==\">https://segmentfault.com/a/1190000040124650</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9NYWluX1BhZ2U=\">https://wiki.osdev.org/Main_Page</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NmZW5vbGxvc2Evb3MtdHV0b3JpYWw=\">https://github.com/cfenollosa/os-tutorial</span></li>\n</ul>\n",
            "tags": [
                "操作系统",
                "从0到1",
                "操作系统",
                "系列长篇",
                "二进制基本功",
                "系列序言"
            ]
        },
        {
            "id": "https://gality.cn/daily/DailyRecord/",
            "url": "https://gality.cn/daily/DailyRecord/",
            "title": "九天揽月",
            "date_published": "2023-08-17T04:19:28.000Z",
            "content_html": "<div class=\"note info no-icon-with-header\">\n<h1 id=\"dig-deeper\"><a class=\"anchor\" href=\"#dig-deeper\">#</a> <ins class=\"danger\">Dig Deeper</ins></h1>\n<ol>\n<li>😁 记录不追求形式，以最舒服的方式进行记录即可。</li>\n<li>🗺️ 每天在总结时要总结所学内容在整体中的位置，不能只是闷着头只做知识储备。</li>\n<li>🧐 及时记录迸发的想法，哪怕无果而终，也要留有痕迹。</li>\n</ol>\n</div>\n<h1 id=\"daily-record\"><a class=\"anchor\" href=\"#daily-record\">#</a> Daily Record</h1>\n<h2 id=\"2023-第39周\"><a class=\"anchor\" href=\"#2023-第39周\">#</a> 2023 - 第 39 周</h2>\n<h3 id=\"918\"><a class=\"anchor\" href=\"#918\">#</a> 9.18</h3>\n<p>非常充实的一天，忙到 12 点才睡，上了一天课，又抽时间帮学弟学妹们完成了面试复盘，明天开始正式迈入科研生活，任务：寻找论文资料并完成研究现状、安全挑战两块内容。</p>\n<h2 id=\"2023-第38周\"><a class=\"anchor\" href=\"#2023-第38周\">#</a> 2023 - 第 38 周</h2>\n<h3 id=\"915\"><a class=\"anchor\" href=\"#915\">#</a> 9.15</h3>\n<p>继续被上课和预算填满，抽时间继续更新了资源导引页，新增了「搜寻学习资源」的类目，这里面的网站真是我不愿说出的信息差，不过呢，即然都说了「开发共享」，又怎么能有所保留呢？</p>\n<p>同样给自己留一个思考题：目前本页的更新中，由于每天记录内容其实很短，反倒是标题占用了大多数的空间，信噪比太低了，要考虑要不要优化一下格式了。</p>\n<h3 id=\"914\"><a class=\"anchor\" href=\"#914\">#</a> 9.14</h3>\n<p>上课！好多课！其余时间都在整资源页，终于小具规模，还是很有成就感的，希望能帮助到一些人，这里补一下想做但还没有做的分类：图书推荐、安全资讯平台汇总、赚点外快....（暂时先这么多）</p>\n<h3 id=\"913\"><a class=\"anchor\" href=\"#913\">#</a> 9.13</h3>\n<p>上午上课加忙预算，下午完成了 Mac 下 gdb 的安装，真不戳～</p>\n<h3 id=\"912\"><a class=\"anchor\" href=\"#912\">#</a> 9.12</h3>\n<p>一整天都在重新调整整个预算表格的格式，估计是要熬夜才能改完了 Orz</p>\n<h3 id=\"911\"><a class=\"anchor\" href=\"#911\">#</a> 9.11</h3>\n<p>上了整天课，课上又没发干自己的事，完全没有时间做其他的事情🥺</p>\n<h2 id=\"2023-第37周\"><a class=\"anchor\" href=\"#2023-第37周\">#</a> 2023 - 第 37 周</h2>\n<h3 id=\"99-910\"><a class=\"anchor\" href=\"#99-910\">#</a> 9.9-9.10</h3>\n<p>周末好好玩～</p>\n<h3 id=\"98\"><a class=\"anchor\" href=\"#98\">#</a> 9.8</h3>\n<p>Debug 中，操作系统好难调试，没有办法进行指令调试，只能插值来调试，去了解下怎么用 qemu 做调试？留个小任务，去学着调试下吧。</p>\n<h3 id=\"97\"><a class=\"anchor\" href=\"#97\">#</a> 9.7</h3>\n<p>终于有时间做自己的事情了，上午修复了一下博客的评论 bug，为静态资源配置了 cdn 加速；下午看了会儿塔式服务器（万一用上呢！），然后继续修改部分预算问题并继续进行操作系统的更新，完成了保护模式的部分。</p>\n<h3 id=\"96\"><a class=\"anchor\" href=\"#96\">#</a> 9.6</h3>\n<p>上午完成了预算的初稿，下午去找了财务的老师核对各项问题，晚上还挺有状态的完成了操作系统的 <code>GDT</code>  和保护模式的部分内容，还不错～明天要把～～ <code>loader</code> ~~ 保护模式写完进入虚拟内存的章节啦</p>\n<h3 id=\"94-95\"><a class=\"anchor\" href=\"#94-95\">#</a> 9.4-9.5</h3>\n<p>预算工作第一版接近尾声，一定要把第一版写完，明天开始继续操作系统</p>\n<h2 id=\"2023-第35-36周\"><a class=\"anchor\" href=\"#2023-第35-36周\">#</a> 2023 - 第 35-36 周</h2>\n<h3 id=\"92-93\"><a class=\"anchor\" href=\"#92-93\">#</a> 9.2-9.3</h3>\n<p>周末基本在学校活动、应酬、改预算之间度过，操作系统 0...</p>\n<h3 id=\"91\"><a class=\"anchor\" href=\"#91\">#</a> 9.1</h3>\n<p>操作系统进度缓慢，明天尽量把预算弄完，然后好好学操作系统吧</p>\n<h3 id=\"831\"><a class=\"anchor\" href=\"#831\">#</a> 8.31</h3>\n<p>接触了点项目预算编写的知识并编写了一份财务预算说明书，抽了一点时间给操作系统的第四篇文章开了点头，希望两天内能完成第四章吧，加油！</p>\n<h3 id=\"830\"><a class=\"anchor\" href=\"#830\">#</a> 8.30</h3>\n<p>开学报道～参观了一下学校，体验了食堂，还是很不戳的～</p>\n<h3 id=\"827-829\"><a class=\"anchor\" href=\"#827-829\">#</a> 8.27-8.29</h3>\n<p>又是当懒狗的一天，摆了很长时间，好在迷途知返，抽了点时间看操作系统～</p>\n<h3 id=\"825-826\"><a class=\"anchor\" href=\"#825-826\">#</a> 8.25-8.26</h3>\n<p>抽空回家进行了各种档案工作，陪陪家人，基本摸不到电脑...</p>\n<p>不过还是利用一点点时间把操作系统第 3 章完成了✌️</p>\n<h3 id=\"824\"><a class=\"anchor\" href=\"#824\">#</a> 8.24</h3>\n<p>难得休息，打了打游戏，出去应酬了一圈，就没有进行学习任务 (爽～</p>\n<h3 id=\"823\"><a class=\"anchor\" href=\"#823\">#</a> 8.23</h3>\n<p><s class=\"danger\">终于，项目结束了，可以好好休息一下了，幸福到流泪😭</s></p>\n<p>上午完成了 baidu、google、bing 的 SEO 索引，等待一天时间就可以看分析数据了，可以通过改善关键字来提升 SEO 排名，既然准备好好经营，为什么不让更多人看到呢😊</p>\n<p><s>必须吐糟一下，baidu 的这个站长工具真的垃圾，google 3 分钟就配好了，就这个百度，用站长工具还需要实名认证，实名认证就算了，还需要扫脸，牛</s></p>\n<p>下午接着完成 <code>mbr</code>  编写的剩余部分的内容，还是剩一点点小尾巴没有完成，有一点点可惜，留着明天完成吧～😁</p>\n<h3 id=\"822\"><a class=\"anchor\" href=\"#822\">#</a> 8.22</h3>\n<p>整体效率还行，完成了博客的 aligolia 的搜索配置，完成了操作系统从 0 到 1 的第二篇文章，第三篇开了个头，使用 figma 作为画图工具还是有些大材小用了，浪费了点时间，需要找一个功能更简单、更便捷的画图工具！</p>\n<h3 id=\"821\"><a class=\"anchor\" href=\"#821\">#</a> 8.21</h3>\n<p>今天效率极低，只完成了操作系统序言部分的编写还大多都是借鉴别佬的，感觉稍微有点浮躁，没有沉下心，倒是听了很多财经的科普 hhh，明天要调整下状态好好学技术～</p>\n<h2 id=\"2023-第34周\"><a class=\"anchor\" href=\"#2023-第34周\">#</a> 2023 - 第 34 周</h2>\n<h3 id=\"820\"><a class=\"anchor\" href=\"#820\">#</a> 8.20</h3>\n<p>继续处理博客的遗留问题，包括：</p>\n<ul>\n<li>精选分类封面图片无法加载</li>\n<li>主题特殊样式学习</li>\n<li>主题样式的一点点 bug 的修复</li>\n<li>comment 表情包引入</li>\n<li>默认模版更新</li>\n</ul>\n<p>其实都是小问题，中间由于要调 bug，也去学习了一点 <code>Nunjunks</code>  和 <code>stylus</code>  语法，对于 hexo 的实现和现在使用的主题的实现都有了一定了解，可以更好 DIY 了😁</p>\n<p>对于博客的改动基本进入尾声了，之前预留的待踩坑项也都完成的七七八八了，后面就要注重内容的填充了，冲！</p>\n<h3 id=\"818-819\"><a class=\"anchor\" href=\"#818-819\">#</a> 8.18-8.19</h3>\n<p>虽然是偷偷摸摸，但终算有点时间打理一下博客，完成了博客配色的改变、评论管理系统搭建、图床的适配等等，基本将博客的整体架子搭出来了，后面就算再加，也只是功能的完善、调整或新增。现在其实更重要的是把博客的内容丰富起来了，加油！</p>\n<p>今天反思了一下过去写博客的经历，仔细想想其实之前也有过坚持日更坚持一年的情况，但是随着电脑的更换、服务器的到期最终连记录都已经找不到了，确实有点可惜，希望这次依托 github 可以将数据永久保留，使得我可以再走了很久之后可以回头看看自己来时的路。</p>\n<h3 id=\"817\"><a class=\"anchor\" href=\"#817\">#</a> 8.17</h3>\n<p>情况稍有转机，工作内容有了变化，可以使用自己的电脑了，做了 4 个 1day 的漏洞复现，也算是有些收获吧，顺便开始回忆起了一点点 web 手的记忆 hhh~</p>\n<h3 id=\"814-816\"><a class=\"anchor\" href=\"#814-816\">#</a> 8.14-8.16</h3>\n<p>本来雄心壮志且状态在线的立刻开始记录每日的学习，但实际上却被外部条件无奈的阻止了，迫不得已暂时停止开始坐牢...</p>\n",
            "tags": [
                "日常"
            ]
        },
        {
            "id": "https://gality.cn/ponder/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/",
            "url": "https://gality.cn/ponder/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/",
            "title": "科技协会面试反思与总结",
            "date_published": "2023-08-14T08:02:17.505Z",
            "content_html": "<div class=\"note warning\">\n<p>本篇文章只是我结合了自己两年面试 + 两年旁听的经历的一些思考与总结，中间可能有些想法并不准确，只是希望能有抛砖引玉的作用，能引发学弟学妹们的一些思考；如果你在看的过程中对任何想法有所质疑，欢迎在评论区中留言讨论👏</p>\n<p>为了尽量对一些想法做出没有歧义的解释，部分内容的论述稍显冗余，如果你可以很容易的理解我想说的，那就下一条吧！理解万岁🎉</p>\n</div>\n<div class=\"note primary no-icon\">\n<p>🎯 总的来说，我认为对于 SIPC 的面试官而言，应该做到以下几点：</p>\n<ol>\n<li>明确对面试的认知，摆正心态，能动的设计流程和问题，注重问题的深度而非广度。</li>\n<li>帮助面试者挖掘自身实力与优势，尽量屏蔽因紧张、社恐导致的发挥失常。</li>\n<li>注重挖掘面试者的「真实水平」，不要把重心放在问题是否正确回答了，而应该注重回答的过程，以及隐藏在其下的思考问题的逻辑。</li>\n<li>精心设计题目难度与提问方式，注重引导面试者思考问题。</li>\n<li>因人而异的设置面试策略和评价标准，根据个人特点调整 Task 任务策略。</li>\n<li>从技术和团队的两方面来考虑面试者，诚然有些人技术非常优秀，但可能并不太适合团队合作或 SIPC，So～</li>\n</ol>\n</div>\n<h1 id=\"理念篇\"><a class=\"anchor\" href=\"#理念篇\">#</a> 理念篇</h1>\n<h2 id=\"面试认知\"><a class=\"anchor\" href=\"#面试认知\">#</a> 面试认知</h2>\n<p>在所有讨论之前，我想先说下对于面试的认知，希望能给面试者一点启发，包括：</p>\n<ul>\n<li>面试的目的是为了深入了解面试者，而非难倒面试者。</li>\n<li>面试官其实是 “服务者”，面试的目的是帮助面试者展现他们的优势。</li>\n<li>面试并非轻松的按流程提问，而是需要消耗大量脑力去对问题进行精心设计，进而达到我们了解面试者的目的。</li>\n<li>要注重差异性，对于不同的面试者采取不同的提问策略和评价标准。</li>\n<li>科协的面试官其实是与面试者共同成长的，要在心态上摆正位置。</li>\n</ul>\n<p>思想上的认识是最为重要的，因此以上几点在后面还会反复提及。</p>\n<p>我想说的是，各位面试官能最终进入 SIPC，都是非常优秀的，本身就是一种能力的证明，我们不应该死板的套公式去面试，而应该充分解放思想，抓住我们面试的核心目的，所有流程、规范都是为「<strong>深入了解面试者</strong>」这个核心服务的，也就是说，只要能达到这个目的，采用什么样的手段其实并不重要。</p>\n<h2 id=\"两轮面试\"><a class=\"anchor\" href=\"#两轮面试\">#</a> 两轮面试</h2>\n<p>在科技协会历来的传统中（至少从我开始），整体包括两轮面试，那么为什么安排两轮面试？以及每轮面试中面试官需要重点侧重于哪方面的考察？这些问题是我们应该思考的。以下我们详细谈谈。</p>\n<p>在我个人的理解中，两轮面试的好处如下：</p>\n<ol>\n<li>两轮面试侧重方面不同，帮助全方位的、可信的考察面试者。</li>\n<li>尽量排除一次面试中可能出现的各种人为因素。</li>\n<li>通过两轮面试中的时间差确定面试者短期学习能力和时间规划能力。</li>\n</ol>\n<p>接下来我们分点来详细论述：</p>\n<h3 id=\"不同的侧重\"><a class=\"anchor\" href=\"#不同的侧重\">#</a> 不同的侧重</h3>\n<div class=\"note info no-icon\">\n<p>我个人认为在一轮面试中需要侧重面试者画像建构，二轮面试中侧重面试者画像验证；两轮面试其实是前后相承的，二者顺序不可调换，虽然可以二合一，但是这样效果可能并不太好。</p>\n</div>\n<p>我们从两轮面试中不同的面试形式说起，在我们这一届中，一面的形式采用 <code>面试</code>  + <code>一点点的题目考查</code> ；二面的形式采用 <code>无领导讨论</code>  + <code>代码测试</code>  + <code>面试</code> 的形式。这两种形式中其实就体现了两轮面试侧重点的不同了。</p>\n<h4 id=\"面试者画像建构\"><a class=\"anchor\" href=\"#面试者画像建构\">#</a> 面试者画像建构</h4>\n<p>为了准确建构面试者画像，在第一轮面试中我们需要做到两件事：</p>\n<ol>\n<li>确定 C 语言真实水平</li>\n<li>对综合素质进行考察与记录</li>\n</ol>\n<p>C 语言的考察只是为了测试面试者是否真实的达到了他完成的 Task 的水平，所以我会注重 C 语言<strong>基础知识</strong>的考察，只要确定出 C 语言真实水平即可；在测试出真实水平的同时，也可以侧面看出面试者对于对于学习知识的态度，到底是急匆匆的学习新知识？还是稳扎稳打的前进？还是学不会一个知识点就不前进？这几者在我的观念中，这几者其实并没有显著优势的学习方案，但是我们必须了解到这点，并帮助面试者进行相应的调整。</p>\n<p>但是，其实就算是没有 C 语言进度也是无所谓的，在一面中，我是可以接受面试者仅仅是刚刚接触 C 语言甚至是还没有进行 C 语言学习（当然，面试者必须能够说明自己态度是端正的）。刚经历了高考的折磨，在高三的暑假中好好玩一下又有什么不好呢？0 基础并不影响一个人的优秀，就像有基础也不代表一定会被录取😊，但是如果我发现了面试者试图欺骗我，那么不好意思，这个会很扣分。</p>\n<p>但但是，其实 C 语言的分数占比挺小的（欺骗除外），大概会占 20%-30% 左右。我会更加侧重于对面试者的性格、目标、时间规划、逻辑能力等<strong>综合素质</strong>进行考察。其实就是是聊天啦，一方面可以一定程度上消除面试者的紧张感，另外一方面这种开放式的问题非常考察综合素质；这一点我发现学弟学妹们也会有相应的题库，但是对于回答到底应该 <code>听什么</code> 、 <code>怎么听</code> 以及 <code>怎么追问</code> 上还是欠缺思考，这点我在后面章节会详细讨论。</p>\n<p><strong>总的来说</strong>，一轮面试中面试官做的更多的是信息的搜集工作，在这个过程中我们可以通过对一些问题的回答来进行交叉对比和逻辑推演，进而识别一些掩饰或谎言；但我们在这个阶段更重要的工作是尽可能详细的建构面试者的真实画像并记录下来，以方便在二面中进行针对性的提问和验证。这并不是说在一轮面试中不会刷掉任何人，某些态度不端、品行不端、理念不合的人趁早刷掉就好。</p>\n<h4 id=\"面试者画像验证\"><a class=\"anchor\" href=\"#面试者画像验证\">#</a> 面试者画像验证</h4>\n<p>了解到现在的二面中已经没有了无领导讨论环节，那么对于一面中建构的综合素质画像就无法很好的验证，但这一点其实也还好，可以通过采用初期培训过程中学长学姐与小组配对的形式，通过学长学姐对小组的观察进行判断；另外，素质考察并不是二面的侧重点，在二面中就需要侧重对技术能力的考察（当然，我们本质其实看的是学习能力），毕竟我们是一个以技术能力作为核心竞争力的组织。</p>\n<p>所以，在二面 C 语言考察中，就可以稍微涉及一些<strong>相对</strong>比较偏的知识点了，但这里我要强调，我们出题的目的不是为了得到正确的答案，而是听面试者思考的过程，所以我们不能只是在听到面试者回答出正确 / 错误答案后，一句：” 不错 / 下去再了解下吧 “就完事了，对于正确答案，我们要进一步追问:</p>\n<ul>\n<li>为什么是这样？</li>\n<li>答案的依据是什么？</li>\n<li>那如果变一下还成立吗？</li>\n</ul>\n<p>对于回答不出来或错误答案的情况，我们需要引导面试者：</p>\n<ul>\n<li>你仔细想想 xxx（前置知识）是怎么样的？</li>\n<li>没关系，说说你的思路吧！</li>\n<li>如果我告诉你 xx（可能的疑难点或记忆点）是这样的，那么你有思路吗？</li>\n</ul>\n<p>注意这里我用了相对两字，如果是太偏的知识点其实是没有意义的，哪怕面试者说不出来又能怎样呢？我们也无法判断他到底是否优秀，所以，作为面试官，一定要精心的设计题目的难度和知识点范围，可以通过<strong>组合知识点</strong>来增加难度，而不要去追着一些偏门的知识进行询问，这样才能得到有意义的回答。</p>\n<p>在验证面试者技术能力的时候一定要与一面中构建的画像进行比对，进而构建二面的问题。例如，对于一个基础不牢的面试者，我们在一面中留的任务是好好复习一下已经学过的内容，那么我们就需要在二面中对于基础知识进行重点考察，观察面试者能否在我们的指导下克服自己的劣势面，这不仅是学习能力的证明，同样也是有无成长可能的证明。通过对每个人的问题的精心设计，我们也可以去验证该面试者在一面中对于自己的评价是否可信，只有通过了交叉对比，我们才算是完成了面试者画像的构建与验证，如果无法通过，我们就要及时修正我们的画像，再去考量该面试者是否通过。</p>\n<h3 id=\"排除人为因素\"><a class=\"anchor\" href=\"#排除人为因素\">#</a> 排除人为因素</h3>\n<div class=\"note info no-icon\">\n<p>要尽可能客观公正的评价每一位面试者，摒除面试中人为因素的影响；同时要记住，面试官是与面试者一同成长的关系！</p>\n</div>\n<p>在面试中，影响面试结果的人为因素来源于两方面：</p>\n<ul>\n<li>面试官的个人因素</li>\n<li>面试者的个人因素</li>\n</ul>\n<p>对于面试官来说，第一点是：人都会对与自己经历相似的人有天然的好感、容易沉溺于夸赞，同样也会对某些人有天然的厌恶。人是一种极其主观的生物，对于事物的评价受主观因素影响很大，为了避免这种情况，通过较为轻松的标准 + 两次面试可以一定程度上的规避因强烈的个人情感导致的不公平现象，当然，一组面试官中有多个人的原因也是如此。</p>\n<p>第二点是：有些面试官可能在面试过程中非常的严肃，或者由于面试官自身的表达原因无法准确的描述问题，都会对面试产生影响，从这一点上来说对于面试者也是有些不公平的。就我们自己而言，我们是需要在每一场面试中不断去反思自己的：提的问题是否有更准确的表达？态度能否更和善？...... 其实对于 SIPC 的面试官而言，要<strong>记得感谢面试者</strong>，因为我们其实是在这个面试的过程中共同成长，而非只是单纯的面试筛选，面试官其实本身也不够成熟，面试者会触发我们<strong>对于技术的思考总结</strong>，我们自己<strong>对未来的规划</strong>、<strong>沟通表达能力的提升</strong>以及<strong>对于 “显而易见问题” 的重新思考</strong>。</p>\n<p>而对于面试者而言，在一次面试中可能会因为各种意外情况导致发挥失常，有些意外并非自己能够控制的，所以进行两次面试也可以最大程度上帮助面试者调整状态，熟悉面试感觉，展现出最好的自己。</p>\n<p>为了<strong>尽可能消除面试官的个人影响</strong>，我建议在面试中采用如下顺序进行问题询问：</p>\n<ol>\n<li>C 语言技术问题</li>\n<li>综合素质问题</li>\n<li>对 SIPC 认知问题</li>\n</ol>\n<p>将可能对于个人倾向有影响的问题放在最后去问，使得我们更容易认真倾听并冷静分析面试者说的话。</p>\n<h3 id=\"判断学习与规划能力\"><a class=\"anchor\" href=\"#判断学习与规划能力\">#</a> 判断学习与规划能力</h3>\n<div class=\"note info no-icon\">\n<p>对于大学生来说，时间规划能力与学习能力其实直接相关，由于本科有大量的课必须要上，能否在紧张的课业中合理安排时间进行技术学习是非常重要的；同时要注意，特殊个体特殊对待，有时我们要有足够的耐心。</p>\n</div>\n<p>这一点我觉得应该不用进行太深的讨论，大家应该都明白，要关注一面到二面之间的成长，而不要做绝对学习进度的对比。但这里我想强调另外一点：<strong>要结合个人的经历、性格去评判成长的大小</strong>。举个例子，对于从小接触计算机编程的面试者，他们学习 C 语言的速度就会快一些，而如果是有些同学从小从来没有接触过计算机，那么学习 C 语言肯定会慢一些，所以要动态的衡量学习的快慢而非制定绝对标准。</p>\n<p>在过往的面试中，我们经常遇见一种情况：面试者在过去除了计算机课就没碰过电脑，再加上自身性格比较内向，有时候说话可能都听不清，看起来整体分数并不高。但是<strong>事实证明</strong>了只要给这样的同学一点时间，他们反倒会比大多数人要优秀。所以我们在面试过程中，要对于这样的面试者给予额外的耐心，多给他们一些时间，再去看看他们的反馈，你可以就会大吃一惊。</p>\n<p><strong>当然</strong>，对不同的人采用不同的评价标准对于每个人而言并不绝对公平，所以这句话只是针对进入科协的两轮面试而言，而对于后面的科协大考核，必须是制定统一的评价标准的。</p>\n<h1 id=\"问题篇\"><a class=\"anchor\" href=\"#问题篇\">#</a> 问题篇</h1>\n<div class=\"note info no-icon\">\n<p>问问题的目的是通过差异化的问题帮助面试者正常甚至超常发挥，来确定不同面试者的真实水平，既不是完成面试流程中的任务、也不是非难倒所有面试者来证明我们优秀。</p>\n<p>为什么要先写理念篇，就是因为我们在面试时一定是在理念的指引下灵活的面试。在设计面试问题的时候一定要能动的去思考我们面试的目的，要想明白我们组织一面、二面是为了什么，去思考我们问的问题能不能达到我们的目的</p>\n</div>\n<p>在多次的旁听中发现了学弟学妹们，尤其是大二的学弟学妹们做主面的时候，对于问题的提问和设计有所欠缺，这个问题非常的普遍，而且又比较具体，我会按照重要程度依次来罗列需要注意的点。</p>\n<h2 id=\"问的深而非问的广\"><a class=\"anchor\" href=\"#问的深而非问的广\">#</a> 问的深而非问的广</h2>\n<p>先来说说问的广而不是问的深的问题：</p>\n<ul>\n<li>问不出面试者的真实水平</li>\n<li>很难了解面试者的综合素质</li>\n<li>面试者很难呈现自己的优势</li>\n<li>很难获得有价值的反馈</li>\n<li>面试官很难判断信息的真伪</li>\n</ul>\n<p>在旁听的过程中，问问题流于表面、广而不深的问题非常的严重，绝大多数学弟学妹们在面试过程中太过于死板的按照流程询问：一道 C 语言、一道技术栈、一道规划...... 面试者有很多有价值继续追问的问题都被忽略了。我极其讨厌这种按照现成的规章制度、不在实际情况的基础上做出修改就照搬照抄的做法，在我看来，这就是 &quot;<strong> 懒</strong> &quot;，而且，是头脑的 “<strong>懒</strong>”。诚然，规范的流程可以提醒我们还有哪些东西没有问到，但是按照流程均匀的分配时间给每一个流程的问题根本就是不动脑子。</p>\n<p>一定要抓住一条主线：<strong>我们是为了深入的了解面试者而提问，而不是为了流程而提问</strong>。</p>\n<p>我们的困境在于：如何在一个极短的时间内，深入的了解面试者。时间短这件事其实本身就意味着想要全面的了解面试者是一种奢望，与其将时间分配在流程上那些无关痛痒的问题上，为什么不把时间全部用来了解你想要了解的东西呢？规范的流程只是参考，而非一定，<strong>不要让思想懒惰</strong>，找到你感兴趣的点不断追问，这个过程反倒会帮助你更深入的了解面试者。</p>\n<p>这里举一个例子：在曾经的面试中，面试者自我介绍时提到了爱好英雄联盟，这个说法大家应该很常见吧，一般情况下我也不会追着这点问，但是情况的特殊在于该面试者除了打游戏外没有别的爱好，C 语言也只是刚刚入门，没有太多可以问的，那么，这个人就 PASS 了吗？并没有，我接着开始问他：</p>\n<ol>\n<li>平时喜欢打哪个位置？ — 打野</li>\n<li>记得野怪的刷新时间吗？— 180S</li>\n<li>怎么平衡刷野和抓人？— 看兵线 xxxxxxx</li>\n</ol>\n<p>这是一个比较极端也很有趣的例子，其实我们可以从回答中看到该面试者对于自己喜欢的东西是会去研究的，那我就觉得这是一种非常好的品质，甚至相比于那些说自己有某某基础，但其实只是看看教程，不求甚解的人，我觉得可能会更优秀一点，哪怕他现在 C 语言只是刚刚开始看我同样让他过了面试，虽然不记得这位同学后来怎么样了，但我相信如果他能对计算机感兴趣，也会发展的很好。这个例子并不是要大家听到面试者爱打游戏就猛猛追问，只是给大家一个参考，我们要<strong>仔细聆听</strong>面试者的介绍，抓住他们感兴趣的点一直追问到自己想听的答案，而非按部就班的提问，会让我们收获更多。</p>\n<h3 id=\"不要被面试者唬住\"><a class=\"anchor\" href=\"#不要被面试者唬住\">#</a> 不要被面试者唬住</h3>\n<p>在面试中还发现一种情况，大概是因为技术栈不交叉的原因，面试者在说自己曾经的技术栈时大概率就是介绍一下就过了，我觉得这是非常可惜的，有技术栈的面试者会比没有技术栈的面试者更好面一些，这里我来说说我面的思路。</p>\n<p>首先，我需要确定面试者的这些技术栈到底是跟着教程按部就班的获取的，还是有一些自己的思考 / 研究在。举个例子，在某次面试中，某面试者介绍自己曾有过游戏破解的经历，于是我详细的问了他：</p>\n<ol>\n<li>是什么游戏</li>\n<li>破解的过程是什么</li>\n<li>怎么学习破解的</li>\n<li>中间有没有遇见什么困难，是怎么解决的</li>\n</ol>\n<p>事实上我只问到了第二个问题就结束了，因为面试者的回答是风灵月影，那么就没必要接着往下问了，而且这个经历也就是一般而已，没有太大的加分。</p>\n<p>「其实，有关游戏破解的知识我也了解的不多，这个时候可以多听面试者讲的东西，我们只需对于逻辑有问题或者讲的不清楚的地方发问就可以了，换个角度看，如果面试者能很清楚的跟面试官讲清楚技术原理，那么其本身就是一个很优秀的面试者了，不是吗？所以，千万不要被面试者唬住」</p>\n<p><strong>总结一下</strong>，我们在面试有技术背景的面试者时，需要通过更加具体的问题在分清楚该面试者对于该技术，到底是简单的跟着教程走，还是自己有所思考 / 研究，然后在回答中去甄别这个人到底是一个有自驱有思考的优秀者，还是只是一个就还好的普通面试者。</p>\n<p><strong>另外</strong>，其实我个人是很喜欢这种问问题的模式的，我在面试中就会经常以这样的方式去询问面试者，个人觉得这是一种很好的问问题的思路，既可以让面试者在熟悉的领域回答问题，还很容易看出面试者的综合素质，也推荐给大家。</p>\n<h2 id=\"问题应是引导而非否定\"><a class=\"anchor\" href=\"#问题应是引导而非否定\">#</a> 问题应是引导而非否定</h2>\n<p>在旁听中，面试官问问题后，如果面试者没有非常快的准确回答，往往会被面试官打断，然后以 “下去再了解了解吧” 结束。我个人觉得这样的问题是无效问题，白白浪费时间。我们一定要明确，我们问问题的过程应该是引导的过程，而非挑刺的过程。通过引导来让面试者回答出问题，或者至少能暴露面试者的思考过程，这道题才是有意义的。如果一味否定，不仅会让面试者紧张以至难以发挥，而且根本难以获取对于面试者的有效评价。</p>\n<p>这一点是有学弟做的比较好的，例如在问字母大小写转换的题目时，会提示 ASCII 码表。可能有些人会觉得前置知识太简单无需引导，其实不是这样的，<strong>引导的过程也是我们梳理自己的知识体系的过程</strong>，一个知识体系不清楚的人是无法做出有效引导的。在引导的过程中，我们强迫自己梳理所学的知识，将「基础」、「结果」通过清晰的逻辑串联起来，你才能做出准确的引导，所以，何不测试测试自己到底有没有梳理好自己的知识体系呢？</p>\n<h2 id=\"c语言知识点应注重基础\"><a class=\"anchor\" href=\"#c语言知识点应注重基础\">#</a> C 语言知识点应注重基础</h2>\n<p>对于面试官而言，要对题目有如下三点反思：</p>\n<ol>\n<li>题目本身是否有非预期解，这道题自己到底搞清楚了吗？</li>\n<li>题目是否为基础问题，是否为面试者常规学习中自然掌握的问题（故意的偏 / 难题除外）？</li>\n<li>自己是否准备了充分的引导？</li>\n</ol>\n<p>有一种极其不应该的情况但是历史上发生过， <code>i++</code>  和 <code>++i</code>  的问题应该是我们面试的高频问题了，但是曾经出过一道题目，由于没有考虑到不同平台编译器的优化问题，导致其实是有非预期解的，幸好面试的时候我在场，没有闹笑话。虽然不要求面试官在出题时对于 C 语言、编译器优化、操作系统有充分的了解，但是至少应该保证代码是能跑通的，且答案与实际执行结果是一致的。</p>\n<p>如果题目本身就非面试者自然掌握的范围，那么问题本身的价值就不是很大，如果是故意为之，那么该有的引导到位了吗？我们要明确一点：偏题如果有充分的引导，可以考察到面试者的逻辑思维能力；但如果没有引导，那就是废题。</p>\n<h2 id=\"问题应清晰明确且不带明显的对错倾向\"><a class=\"anchor\" href=\"#问题应清晰明确且不带明显的对错倾向\">#</a> 问题应清晰明确且不带明显的对错倾向</h2>\n<p>这里我直接给出一些问题实例对比，请大家仔细体会其中的差别：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原始问题</th>\n<th style=\"text-align:center\">不好的点</th>\n<th style=\"text-align:center\">变换问题</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">如果你室友在你做题时拉你去打游戏，你会怎么做？</td>\n<td style=\"text-align:center\">对错倾向太过明显</td>\n<td style=\"text-align:center\">请问你怎么均衡技术时间、娱乐时间和社交时间？</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">介绍一下数组吧</td>\n<td style=\"text-align:center\">问题范围太大</td>\n<td style=\"text-align:center\">请你介绍下数组怎么初始化 / 与字符串的区别 /......</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">你对科协有什么看法？</td>\n<td style=\"text-align:center\">没问题</td>\n<td style=\"text-align:center\">开放类问题是可以这样问的</td>\n</tr>\n</tbody>\n</table>\n<p>我们在问问题之前要先在脑中斟酌一下，这一点并不难做到，同样的问题，变换一下问法，就可能能问出你想要的答案了。</p>\n<h2 id=\"不要随便问方向内问题\"><a class=\"anchor\" href=\"#不要随便问方向内问题\">#</a> 不要随便问方向内问题</h2>\n<p>如果面试者没有表现出明显的对于某方面的兴趣，或是过往技术背景中没有明显的方向的背景，请不要突然就问某一个细分方向（前端 / 后端 / 产品 / 安全...），真的很奇怪诶！</p>\n<h1 id=\"任务篇\"><a class=\"anchor\" href=\"#任务篇\">#</a> 任务篇</h1>\n<p>这一章表达的思想其实前面都有体现，这里单独拿出来再说一下也是因为非常重要，希望每一位面试官认真对待。</p>\n<ul>\n<li>\n<p>留 Task 的依据</p>\n<p>正如上面说的，要<strong>根据不同的面试者来制定不同的面试策略和评价标准</strong>，同理，对于不同的面试者留 Task 的多少也应该有所不同，例如：对于基础不牢的同学我们甚至可以不留更多 Task，让他把已经做过的 Task 好好复习也是可以的。对于每一类型的面试者，面试官都需要认真思考留 Task 的策略。</p>\n<p>在二面中，对于没有完成既定 Task 目标的面试者我们也要<strong>保持耐心</strong>，认真的听他们说原因，同时也需要<strong>反思</strong>我们留的 Task 的任务是否是合理的，其实对于大家目前的能力来说，<strong>偏离才是常态</strong>，如果绝大部分人都按要求完成了 Task 任务，那么这时就要警惕是否可能是一些我们不希望看到的事情发生了，要进行更加认真的验证。</p>\n</li>\n<li>\n<p>留任务应具体</p>\n<p>我们的面试官在面试过程中经常会说 “下去了解下” 这样的话，这一点本身没什么问题，但是如果不提示面试者下去应该了解 “什么” 知识，那就有可能导致问题了。</p>\n<p>例如我们问：如果创建一个超级大的数组可能产生什么问题？那么我们留任务的时候就要说：下去可以了解下栈溢出的知识。我们需要帮助面试者具体出需要了解的知识而不是只是一句 “下去了解下” 就完了。</p>\n</li>\n</ul>\n<p>不过以上两点在我晚上做了简单的面试复盘后，面试官已经有了很好的改变，<strong>特别棒！</strong></p>\n<h1 id=\"制度篇\"><a class=\"anchor\" href=\"#制度篇\">#</a> 制度篇</h1>\n<p>本章就是一些简单的面试制度上的建议了，经验性的东西就写的比较简略</p>\n<ul>\n<li>\n<p>时间把控</p>\n<p>建议<strong>以 30 分钟为区间</strong>通知面试者等候面试，大概每一桌等待的人数保持在 2-3 人是比较合适的，既不会太耽误面试者时间，也可以应对一些面试者晚到等意外情况，更高效的利用时间。</p>\n</li>\n<li>\n<p>题目控制</p>\n<p>如果是多天 / 多场面试，建议准备<strong>多套题目</strong>，防止因泄题导致的技术面失真。</p>\n</li>\n</ul>\n<h1 id=\"愿景与使命\"><a class=\"anchor\" href=\"#愿景与使命\">#</a> 愿景与使命</h1>\n<p>鲁迅先生曾说</p>\n<blockquote>\n<p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。</p>\n</blockquote>\n<p>科技协会的愿景是帮助每一个热爱计算机、热爱技术的同学在技术的大海中遨游；SIPC 作为一个学生组织，使命是帮助整个学院乃至学校的同学们提升技术水平。所以，<strong>面试不必过于严苛，培训不用过于保密</strong>，如若能让每一位热爱技术的同学有所收获，那便是我们最大的成就。</p>\n",
            "tags": [
                "思考与沉淀",
                "思考"
            ]
        },
        {
            "id": "https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/",
            "url": "https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/",
            "title": "blog搭建&Hello world",
            "date_published": "2023-08-14T08:02:17.000Z",
            "content_html": "<div class=\"note primary no-icon-with-header\">\n<h1 id=\"待踩坑项\"><a class=\"anchor\" href=\"#待踩坑项\">#</a> <ins class=\"danger\">待踩坑项</ins></h1>\n<p>🎉已经全部完成啦，后续将注重内容更新～🎉</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_0\"> valine admin: 通过脚本<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0Rlc2VydHNQL1ZhbGluZS1BZG1pbi5naXQ=\">一键部署</span>完成，<s class=\"info\">模版自身有点小 bug，通过调试 JS 解决</s> <s class=\"danger\">其实不算 bug，本质是配置问题，修改完配置后就没有 bug 了</s>  确实就是 bug，已经修复了 Orz</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> 文章图片：七牛云 + 学生认证 + 图片压缩 + CDN 加速，目前图片加载速度较为满意</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_2\"> 主题样式更改以更符合自己口味：已完成白天 &amp; 黑夜两套色系的适配， 顺便推荐一下飞书，UI 配色真的很好抄 (博客白天模式的配色和本人命令行均是～)</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_3\"> 默认图片：通过图传解决，plus：添加更多图片以减少随机的重复</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_4\"> 主题特殊样式：<span class=\"rainbow\">该页面已通过主题特殊样式复写～</span></label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_5\"> 主页精选分类实现：花费了半天成功实现，中间有些坑值得记录一下，详见：<a href=\"https://gality.cn/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/#%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E6%AD%A3%E5%B8%B8%E4%BD%86%E9%83%A8%E7%BD%B2%E5%90%8E404\">这里</a></label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_6\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_6\"> Valine 表情源引入：使用了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dhbWVyTm9UaXRsZS9WYWxpbmUtTWFnaWM=\"> Valine-Magic</span> 的表情源来实现</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_7\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_7\"> 主题样式 bug 修复：修复当标题在标签块中时样式重叠的 bug</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_8\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_8\"> 主题样式功能新增：<s>新增对 front-matter 中 summary 字段的支持</s>，使用 <code>excerpt</code>  即可实现摘要编写工功能</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_9\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_9\"> 主题样式功能修正：不知道是因为改动了哪里，导致文章中的超链接样式没有下滑线，通过对代码进行修正修复了这个问题。</label></p>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" id=\"cbx_10\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_10\"> algolia: 申请完成并且在今天完成了配置，其中遇见一点点小坑 (配置原因)，很快便解决了</label></p>\n</li>\n</ul>\n<p>2023.9.7 补</p>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_11\"> MiniValine Bug 修复：页脚最新评论因多加 <code>/</code>  导致无法正确跳转到文章评论，通过改变 MiniValine 解决了这个问题。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_12\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_12\"> 本地资源走 jsdeliver 进行 CDN 加速：速度提升巨大，真心感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==\"> jsdelivr</span> 这样的免费项目。</label></li>\n</ul>\n</div>\n<h1 id=\"blog-搭建\"><a class=\"anchor\" href=\"#blog-搭建\">#</a> Blog 搭建</h1>\n<p>无法白嫖阿里云 or 腾讯云的学生优惠后，用个人云服务器作为博客的花费属实有点不能承受，于是又回归了 <code>Github Pages + Hexo</code>  的白嫖之路，途中踩到了诸多坑，这里稍微记录一下：</p>\n<h2 id=\"主题\"><a class=\"anchor\" href=\"#主题\">#</a> 主题</h2>\n<p>逛<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy9pbmRleC5odG1s\"> themes</span> 的时候偶然看见了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==\"> ShoKa</span> 主题，除了有点太过二次元外特效和布局还是很对我胃口的，唯一一点在于作者两年前就不更新了，看到最后一次更新时间时，我就意识到，安装之旅一定时会踩坑的...，咬咬牙，还是踩一遍吧</p>\n<h2 id=\"node版本\"><a class=\"anchor\" href=\"#node版本\">#</a> node 版本</h2>\n<p>作为一个两年前的项目，用最新 LTS 版本 18.17.1 果不其然会出问题，主要在于该项目所依赖的插件 <code>hexo-renderer-multi-markdown-it</code>  中依赖了 <code>puppeteer</code> ，在已经解决了网络问题的情况下，仍然会报一个错误：</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>TypeError <span class=\"token punctuation\">[</span><span class=\"token constant\">ERR_INVALID_PROTOCOL</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> Protocol <span class=\"token string\">\"https:\"</span> not supported<span class=\"token punctuation\">.</span> Expected <span class=\"token string\">\"http:\"</span></pre></td></tr></table></figure><p>最终解决方法为将 node 版本降至 12.x：</p>\n<figure class=\"highlight sh\"><figcaption data-lang=\"sh\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> n <span class=\"token number\">12.22</span>.12</pre></td></tr></table></figure><h2 id=\"deploy插件\"><a class=\"anchor\" href=\"#deploy插件\">#</a> deploy 插件</h2>\n<p>hexo 官方的 deploy 插件为： <code>hexo-deployer-git</code> ，提供了一键部署功能，而官方文档给的不是特别详细，token 变量赋值为 github 的 access token 仍然无法认证成功，这里直接给出认证成功的配置：</p>\n<figure class=\"highlight yaml\"><figcaption data-lang=\"YAML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//Your_Access_Token@github.com/&lt;Name<span class=\"token punctuation\">></span>/&lt;Name<span class=\"token punctuation\">></span>.github.io</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> main</pre></td></tr></table></figure><h2 id=\"包管理器\"><a class=\"anchor\" href=\"#包管理器\">#</a> 包管理器</h2>\n<p>不知道是不是因为 node 降级之后没有把 <code>yarn</code>  降级的原因，当我用 <code>yarn add xxx</code>  安装依赖后，再次使用 <code>hexo</code>  指令时，会出现报错 <code>cannot find module 'hexo'</code> ，这里没有继续探究下去了，直接放弃 <code>yarn</code> ，使用 <code>npm</code>  就没有问题了。</p>\n<h2 id=\"leancloud-valine\"><a class=\"anchor\" href=\"#leancloud-valine\">#</a> LeanCloud + Valine</h2>\n<p>该主题默认支持了使用 <code>valine+LeanCloud</code>  的方式实现无后端评论功能，有问题的地方在于 leanCloud 现在做了默认策略，无法通过默认地址进行访问，必须通过 <code>应用 -&gt; 设置 -&gt; 应用凭证 -&gt; 域名白名单</code> 中的 Request 域名进行访问，在 <code>_config.yaml</code>  中的配置项中，必须在 <code>serverURLs</code>  为上述域名 <code>xxxx.api.lncldglobal.com</code>  才可以正常使用</p>\n<h2 id=\"本地预览正常但部署后404\"><a class=\"anchor\" href=\"#本地预览正常但部署后404\">#</a> 本地预览正常但部署后 404</h2>\n<p>刚开始遇见这个问题是在实现分类图片时，图片就在 github 的仓库对应位置，但是加载页面时却 404，用英文搜了好久但其实没有搜到点上，这个问题的本质在于，默认 njk 模版在引用图片时使用的是绝对路径 <code>/MISC/cover.jpg</code> ，本地没有问题，但是部署到 github 后会出现无法访问的情况，此时将模版更改为 <code>MISC/cover.jpg</code>  即可，对我来说，问题的复杂在于，刚开始没有定位到问题，以为是 url 路径大小写的问题，所以就把 <code>MISC</code>  改为了 <code>misc</code> ，这有导致了新的问题，这个才是更值得记录。</p>\n<p>由于 URL 路径对于大小写是敏感的，所以如果服务器路径为 <code>http://xx.com/misc/cover.jpg</code> ，那么此时，用 <code>http://xx.com/MISC/cover.jpg</code>  是访问不到的，所以我在更改大小写后，仍然有 404 的问题，且此时，我注意到在本地的 public 文件夹中， <code>MISC</code>  文件夹已经变为了 <code>misc</code> ，但 <code>hexo d</code>  后，github 仓库中仍然为 <code>MISC</code> ，原因在于 git 本身是对大小写不敏感的，即 <code>MISC</code>  和 <code>misc</code>  对于 git 来说是一样的，而 hexo 本身又是差量更新，所以大小写的变动并没有记录更新，仍然用之前的大写版本，该问题的解决方法如下：</p>\n<ol>\n<li>修改 <code>&lt;root&gt;/.deploy_git/.git/config</code>  文件，将 <code>gnorecase = true</code>  改为 <code>false</code>  (使得 git 对大小写敏感)</li>\n<li>删除 <code>&lt;root&gt;/.deploy_git</code>  下的 <code>MISC</code>  文件夹 (该文件夹内才是真正的 git 仓库)</li>\n<li><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>  重新部署</li>\n</ol>\n<div class=\"note warning no-icon\">\n<p>PS：图片路径问题的本质其实是主题原本的写法是用了 jsdelivr 去加速静态资源的，当配置了 <code>statics</code>  为 jsdelivr 地址时，资源加载不会出错，如果是配置为 <code>/</code> ，则会存在上述问题。</p>\n</div>\n<h2 id=\"jsdelivr加速及刷新缓存\"><a class=\"anchor\" href=\"#jsdelivr加速及刷新缓存\">#</a> Jsdelivr 加速及刷新缓存</h2>\n<p>对于 github 项目来说，配置 Jsdelivr 加速极其简单，直接将资源的访问链接替换成 CDN 链接即可，CDN 链接为：</p>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">https</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//cdn.jsdelivr.net/gh/您的Github用户名/项目仓库名@版本/文件路径</span></span></pre></td></tr></table></figure><p>例如，我自己改过的 MiniValine 的地址为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dhbGl0eTM2OS9NaW5pVmFsaW5l\">https://github.com/Gality369/MiniValine</span> ，项目内的目录为 <code>dist/MiniValine.min.js</code>  ，发布了一个 release 版本为 “v4.2.2-beta11”。</p>\n<p>那么我只需将地址替换为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2dhbGl0eTM2OS9NaW5pVmFsaW5lQHY0LjIuMi1iZXRhMTEvZGlzdC9NaW5pVmFsaW5lLm1pbi5qcw==\">https://cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js</span> 就可以让 jsdeliver 抓取我的 js 文件并通过 CDN 加速传给我。</p>\n<p>注意，这其中涉及到缓存问题，例如当我改变了上述 js 文件后，由于 jsdelivr 会存一份缓存文件便于加速获取过程，所以当我请求时可能只能获取老版本的 js，我们可以通过将 <code>cdn</code>  换成 <code>purge</code>  的方式来告诉 jsdelivr 重新获取文件并刷新缓存，例如：</p>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>//刷新前</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">https</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>//强制刷新，返回 status: finished 代表刷新成功</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">https</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//purge.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js</span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>//重新访问即可</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">https</span><span class=\"token punctuation\">:</span><span class=\"token header-value\">//cdn.jsdelivr.net/gh/gality369/MiniValine@v4.2.2-beta11/dist/MiniValine.min.js</span></span></pre></td></tr></table></figure><p>jsdelivr 大幅提升了网站的访问速度，最重要的是免费！！！</p>\n<p>再次由衷感谢这样的项目🙏</p>\n<h1 id=\"hello-world\"><a class=\"anchor\" href=\"#hello-world\">#</a> Hello World</h1>\n<p>仔细算算搭建个人博客已经有过大概 7、8 次了，每次总是因为各种各样的原因，最终都荒废了，记录的笔记，分享的技术也都遗失了，确实也有点遗憾。</p>\n<p>本来计划等开学之后再重新搭博客来记录 &amp; 激励自己，但是在认真看了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ldGVybmFsc2FrdXJhMTMuY29tLw==\"> Sakura 师傅</span>的博客之后，大受震撼，几经思索之后，不禁问自己为什么要等到 10 几天后呢？为什么不能现在开始呢？于是，说做便做，今天便将诸多坑都踩了踩，产出了新博客的第一篇文章。</p>\n<p>博客将具体怎么发展，写那些内容，暂时还没有想好，但是一定会置顶一篇自己的每日进展作为激励，希望可以一直坚持下去，每天更新。</p>\n<p>末了，写一句激励自己的话吧！</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"泰山之管穿石，单极之绠断干。水非石之钻，索非木之锯，渐靡使之然也\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "杂项",
                "踩坑",
                "杂项",
                "踩坑"
            ]
        }
    ]
}