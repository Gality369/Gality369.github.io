<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="KbCOz5IFs80bU-psVUCv9C7SOLzVWto8d7_5ZSsX7I0"><meta name="baidu-site-verification" content="codeva-KcLqIZYGXd"><link rel="alternate" type="application/rss+xml" title="藏器于身" href="https://gality.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="藏器于身" href="https://gality.cn/atom.xml"><link rel="alternate" type="application/json" title="藏器于身" href="https://gality.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/css/app.css?v=0.2.5"><meta name="keywords" content="操作系统,os,从零开始,boot,loader,nasm"><link rel="canonical" href="https://gality.cn/os/03-loader/"><title>03-Loader 编写之进入保护模式 - 从 0 到 1 - 操作系统 | Samadhi = 藏器于身 = 待时而动</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">03-Loader 编写之进入保护模式</h1><div class="meta"><span class="item" title="创建时间：2023-08-31 16:08:10"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-31T16:08:10+08:00">2023-08-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Samadhi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://imgcdn.gality.cn/blog/nmj8uf.jpg"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/14wa89.png"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/9m7q8s.png"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/065frw.jpg"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/e2h6c4.jpg"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/2023-08-19-wallhaven-qzmlj5_2560x1440.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/os/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/os/0-1/" itemprop="item" rel="index" title="分类于 从 0 到 1"><span itemprop="name">从 0 到 1</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://gality.cn/os/03-loader/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/avatar.png"><meta itemprop="name" content="Gality"><meta itemprop="description" content="待时而动, 安全杂记 & 日常随感"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="藏器于身"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>本章是操作系统从 0 到 1 系列的第四篇文章，主要讲解了 loader 需要完成的任务以及其中涉及到的知识点。本章先总体介绍 loader 的工作，然后逐步实现部分 loader 的工作（虚拟内存之前）并讲解相关知识点，由于虚拟内存相关的知识庞大且重要，我们会在下一章进行详细探讨。</p></div><div class="note warning"><p><em>Concepts you may want to Google beforehand: GDT, protected mode, segment register, interrupts, pipeline</em></p></div><h1 id="loader的工作"><a class="anchor" href="#loader的工作">#</a> Loader 的工作</h1><p>总的来说，loader 的工作为以下几项（也是 loader 到 kernel 的步骤）：</p><ol><li>禁用中断</li><li>使能 A20 地址线（现在的设备都是默认使能的，所以可以跳过）</li><li>建立 GDT</li><li>进入保护模式并刷新 cpu 管道、初始化段寄存器和栈</li><li>建立 kernel 页目录（ <code>page directory</code> ）和页表（ <code>page tables</code> ）</li><li>打开虚拟内存（ <code>virtual memory</code> ），进入 <code>paging</code> 模式</li><li>加载 <code>kernel</code> 镜像到内存</li><li>执行 <code>kernel</code> 代码，控制权转交给 <code>kernel</code></li></ol><h1 id="loader编写"><a class="anchor" href="#loader编写">#</a> Loader 编写</h1><h2 id="禁用中断"><a class="anchor" href="#禁用中断">#</a> 禁用中断</h2><p>禁用中断通过设置 <code>IF</code> flag 来实现，当 <code>IF</code> flag 被设置为 0 时，系统会屏蔽中断命令；禁用中断非常简单，只需要一行命令即可：</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>cli</pre></td></tr></table></figure><p>如果你看了很多教程的话，可能会发现，有的教程中有这行代码，而有的没有，甚至在自己写的 loader 中不禁用中断可能也不会有什么问题，但是，这里是 “可能”，如果中断发生在实模式进入保护模式之前和之后，系统都没有问题，但在模式切换进行时发生中断就会发生异常。这个情况概率比较低，少量的验证是没法复现此问题的，所以我们最好还是加上 <code>cli</code> 命令。</p><h2 id="使能a20地址线"><a class="anchor" href="#使能a20地址线">#</a> 使能 A20 地址线</h2><p>由于现在设备会在启动时自动使能 A20 地址线，所以这一步可以跳过，不过我们的教程为了完整性，还是稍微讲一下。</p><p>「A20 其实是指第 21 根地址线，因为地址线是从 0 开始计数的。」</p><p>需要该步骤也是历史原因导致的，<a href="https://gality.cn/os/02-mbr/#%E4%BB%8E%E9%80%9A%E7%94%B5%E5%BC%80%E5%A7%8B">我们之前讲过</a>，在 CPU 发展早期（8086 时代），CPU 地址线只有 20 位，此时寻址还需要还需要经过转换。经过 CPU 的不断发展（80286 时代），地址线从 20 根扩展到了 24 根，能访问的内存达到了 2<sup>24</sup>M，但是在 CPU 设计时是向下兼容的，所以，80286 CPU 在实模式时表现应该和 8086 CPU 一致，但其实 80286 芯片却存在一个 Bug：因为 80286 有了 A20 地址线，如果程序员访问 <code>100000H ~ 10FFEFH</code> 之间的内存，系统将实际访问这块内存，而不是像 8086/8088 一样从 0 开始。</p><p>所以为了解决上述兼容问题，IBM 使用实模式下本应无用的 A20 地址线来进行设置，当 A20 被使能时，程序员给出 <code>100000H ~ 10FFEFH</code> 之间的地址的时候，系统将真正访问这块内存区域；若 A20 为被使能，则会按照实模式下对地址取模进行访问。</p><p>使能 A20 的代码非常简单，只需要记住即可</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>in <span class="token register variable">al</span>, <span class="token number">92h</span> <span class="token comment">; 2. enable A20</span></pre></td></tr><tr><td data-num="2"></td><td><pre>or <span class="token register variable">al</span>, <span class="token number">00000010b</span></pre></td></tr><tr><td data-num="3"></td><td><pre>out <span class="token number">92h</span>, <span class="token register variable">al</span></pre></td></tr></table></figure><h2 id="建立gdt"><a class="anchor" href="#建立gdt">#</a> 建立 GDT</h2><details class="info"><summary>什么是GDT？</summary><div><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HRFRfVHV0b3JpYWw=">GDT</span>（ <strong>Global Descriptor Table</strong>）即全局描述符表，又叫段描述符表，本质其实就是一种专用于 <code>IA-32</code> 和 <code>x86-64</code> 体系结构的二进制数据结构，该表位于内存中，具体位置保存在 <code>GDTR</code> 寄存器中，其条目描述并规定了不同内存分区的各种特征，包括基地址、大小和访问特权如可执行、可写等。 在 Intel 的术语中，这些内存区域被称为 <code>segment</code> 。</p><p>我们在上一章中提到过，CPU 通过 <code>段基地址</code> + <code>段内偏移</code> 的方式来扩展寻址空间，类似的，在保护模式下，CPU 通过 GDT 中记录的基地址和偏移地址实现寻址，因此可以通过 GDT 中记录的段的信息来进行内存的保护（对比实模式下，所有程序都可以访问任意内存）。</p></div></details><h3 id="gdtr"><a class="anchor" href="#gdtr">#</a> GDTR</h3><p>根据<span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9HbG9iYWxfRGVzY3JpcHRvcl9UYWJsZQ==">手册</span>，GDT 的地址应存储在 <code>GDTR</code> 寄存器中，这个过程通过汇编指令 <code>LGDT</code> 进行加载，参数指向 <code>GDT Descriptor</code> 结构：</p><p><img data-src="http://imgcdn.gality.cn/blog/qsb20j.png" alt="GDT Descriptor"></p><ul><li><strong>Size</strong>：表示 GDT 的大小，以字节为单位，实际大小值为 <code>Size+1</code> ，这是因为 <code>Size</code> 的最大值是 65535，但是 GDT 的最大值为 65536（8192 条数据）；同时，GDT 的 <code>Size</code> 不能为 0</li><li><strong>Offest</strong>：GDT 的线性地址（并不是物理地址，而是分页地址）</li></ul><p>同时，上图中我们也可以看出 <code>LGDT</code> 命令在 32 位和 64 位下采用不同的方式载入数据， <code>Offest</code> 在 32 位下只有 4 字节长度，而在 64 位下有 8 字节。</p><h3 id="gdt"><a class="anchor" href="#gdt">#</a> GDT</h3><p>GDT 中的条目占 8 字节，在内存中的形式如下：</p><p><img data-src="http://imgcdn.gality.cn/blog/ug568w.png" alt="GDT"></p><p>注意，GDT 中的第一个条目 (Entry 0) 永远为空，所以段数据应从第二个条目开始存储；表中的项由段选择器（Segment Selectors）存取，段选择器通过汇编指令或中断等硬件函数加载到段寄存器中。</p><p>GDT 中每一项都有一个名为 <code>Segment Descriptor</code> 复杂的结构，该结构长度为 8 Bytes，示意图如下：</p><p><img data-src="http://imgcdn.gality.cn/blog/ir3ukr.png" alt="System Segment Descriptor"></p><ul><li><strong>Base</strong>：一个 32 位值（不连续的黄色部分），记录了该段的起始地址「图中 Base address 后的括号说明了改部分在整个 Base 中的位数」</li><li><strong>Limit</strong>：一个 20 位值（不连续的粉红色部分），记录最大可寻址单元，以 1 字节为单位（最大寻址 1M），或以 1 页（4 KB）为单位；因此，在 32 位下，如果选择以页为单位且 limit 设为 <code>0xFFFFF</code> ，那么该段将覆盖整个 4 GB（4KB*1M ）空间「图中括号内数字含义同 Base」</li></ul><details class="info"><summary>64位下的GDT</summary><div><p>上述图片展示的是 32 位模式下的 GDT，而在 64 位模式下，段保护机制基本被废弃了，更多的是使用页机制，因此，服务于段机制的 GDT 表项就少很多；又由于 64 位下引入的 <code>IA-32e</code> 指令集不再兼容老旧的 8086 模式，仅有代码段 CS，数据段 DS 仍和 32 位一样使用 64 位，即 8 字节的描述符，其他的段寄存器例如：DS、ES、SS 这样的段寄存器已经不再使用了，GDT 项存在的意义就更小了。</p><p>另一个导致 GDT 在 64 位下不受宠的原因是，其实从 win XP 系统开始，系统进入保护模式后 GDT 的项就没用了，一直就那么空在内存中，甚至还有从系统启动到结束就没用过的表项，不但占地方还给了黑客可趁之机，很多大神看上了这一大片有可读写可执行属性的内存，就把 Shellcode 或者全局数据区布置在这了。</p></div></details><ul><li><p><strong>Access Byte</strong>：一个 8 位值（40-47），代表了该段的访问权限字段，字段参数及含义如下：</p><ul><li><p><strong>P:</strong> 段是否存在，存在 = 1</p></li><li><p><strong>DPL:</strong> 描述符权限级别字段（2 位）， 即该段的<span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9TZWN1cml0eSNSaW5ncw=="> CPU 权级</span>. <strong>0</strong> = 最高权限（内核）, <strong>3</strong> = 最低权限（用户应用）.</p></li><li><p><strong>S:</strong> 描述符类型字段。如果设置为 <code>0</code> ，则定义了一个系统段 (例如 TSS「 <span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9UYXNrX1N0YXRlX1NlZ21lbnQ=">Task State Segment</span> 」、LDT「 <span class="exturl" data-url="aHR0cHM6Ly93aWtpLm9zZGV2Lm9yZy9Mb2NhbF9EZXNjcmlwdG9yX1RhYmxl">Local Descriptor Table</span> 」)；如果设置为 <code>1</code> ，则定义一个代码段或数据段。这两种描述符的 Type 字段结构有所不同，接下来分别来说：</p><div class="note success no-icon"><p><strong>S=0</strong> 时（System Segment Descriptor）</p><ul><li><strong>Type</strong>：定义系统段的类型（32 位模式）<ul><li><strong>0x1:</strong> 16-bit TSS (Available)</li><li><strong>0x2:</strong> LDT</li><li><strong>0x3:</strong> 16-bit TSS (Busy)</li><li><strong>0x9:</strong> 32-bit TSS (Available)</li><li><strong>0xB:</strong> 32-bit TSS (Busy)</li></ul></li><li><strong>Type</strong>：定义系统段的类型（<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ19tb2Rl">Long Mode</span>）<ul><li><strong>0x2:</strong> LDT</li><li><strong>0x9:</strong> 64-bit TSS (Available)</li><li><strong>0xB:</strong> 64-bit TSS (Busy)</li></ul></li></ul></div><div class="note success no-icon"><p><strong>S=1</strong> 时（Code/Data Segment），<strong>Type</strong> 字段会被拆分为以下字段</p><p><img data-src="http://imgcdn.gality.cn/blog/shts2l.png" alt="Access Byte"></p><ul><li><strong>E</strong>：第 43 位，是否可执行位， <code>0</code> 代表该段为数据段，不可执行； <code>1</code> 代表代码段，可执行</li><li><strong>DC</strong>：第 42 位，方向位 / 符合位<ul><li>对于数据段：表示方向位。 <code>0</code> 代表段向高地址增长； <code>1</code> 代表段向低地址生长</li><li>对于代码段：表示符合位。 <code>0</code> 代表只有 <code>DPL</code> 字段中指定的权限可以执行该段代码； <code>1</code> 表示该段代码的执行权限可以小于等于 <code>DPL</code></li></ul></li><li><strong>RW</strong>：第 41 位，可读 / 可写位<ul><li>对于代码段：表示可读位。 <code>0</code> 代表该段不允许读， <code>1</code> 代表可读；代码段永远没有写权限。</li><li>对于数据段：表示可写位。 <code>0</code> 代表该段不可写， <code>1</code> 代表可写；数据段永远有读权限。</li></ul></li><li><strong>A</strong>：第 40 位，访问位，最好设置为 0，CPU 会在该段被访问时自动设置它。</li></ul></div></li></ul></li><li><p><strong>Flags</strong>：一个 4 位值（52-55 位）</p><ul><li><strong>G</strong>：粒度位，指示 <code>Limit</code> 的单位。 <code>0</code> 表示 <code>Limit</code> 单位为 1 字节 (字节粒度)。如果设置为 <code>1</code> ，则 <code>Limit</code> 单位为 4KB 块 (页面粒度)。</li><li><strong>DB</strong>：大小位， <code>0</code> 代表定义了一个 16 位保护模式段， <code>1</code> 表示定义了一个 32 位保护模式段；一个 GDT 可以同时有 16 位和 32 位的位选择器</li><li><strong>L</strong>：长模式代码标志， <code>1</code> 表示该段定义为 64 位代码段，此时 <code>DB</code> 应该设置位 <code>0</code> ； <code>0</code> 表示为其他类型段</li><li><strong>A</strong>：保留位，设为 0 即可</li></ul></li></ul><h3 id="asm"><a class="anchor" href="#asm">#</a> asm</h3><p>以上就是所有有关 <code>GDT</code> 的理论知识啦，现在让我们动手写一下我们的操作系统的 <code>GDT</code> 吧！梳理一下：</p><ol><li><code>GDT</code> 的第一项必须为空项</li><li>至少定义两个段：代码段、数据段（ <code>base</code> 和 <code>length</code> 先一样即可）</li><li>获取 <code>GDT</code> 的地址</li><li>创建 <code>GDT Descriptor</code> 结构用于后续填充 <code>GDTR</code></li></ol><details class="info"><summary>32bit-gdt.asm</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token label function">gdt_start:</span> <span class="token comment">; don't remove the labels, they're needed to compute sizes and jumps</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">; the GDT starts with a null 8-byte</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    dd <span class="token number">0x0</span> <span class="token comment">; 4 byte</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    dd <span class="token number">0x0</span> <span class="token comment">; 4 byte</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">; GDT for code segment. base = 0x00000000, length = 0xfffff</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">; for flags, refer to https://gality.cn/os/03-loader/#gdt</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">; again,  1 bytes = 8 bits | 1 word = 2 bytes = 16 bits</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token label function">gdt_code:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    dw <span class="token number">0xffff</span>    <span class="token comment">; segment length, bits 0-15</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    dw <span class="token number">0x0</span>       <span class="token comment">; segment base, bits 0-15</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    db <span class="token number">0x0</span>       <span class="token comment">; segment base, bits 16-23</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    db <span class="token number">10011010b</span> <span class="token comment">; flags (8 bits), little-endian, so compare the doc. from P to A (high to low)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    db <span class="token number">11001111b</span> <span class="token comment">; flags (4 bits) + segment length, bits 16-19 | length=0xfffff</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    db <span class="token number">0x0</span>       <span class="token comment">; segment base, bits 24-31</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">; GDT for data segment. base and length identical to code segment</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">; some flags changed, again, https://gality.cn/os/03-loader/#gdt</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token label function">gdt_data:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    dw <span class="token number">0xffff</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    dw <span class="token number">0x0</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    db <span class="token number">0x0</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    db <span class="token number">10010010b</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    db <span class="token number">11001111b</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    db <span class="token number">0x0</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token label function">gdt_end:</span> <span class="token comment">; don't remove this label</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment">; GDT Descriptor</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token label function">gdt_descriptor:</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    dw gdt_end <span class="token operator">-</span> gdt_start <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">; size (16 bit), always one less of its true size</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    dd gdt_start <span class="token comment">; address (32 bit)</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">;define some constants for later use</span></pre></td></tr><tr><td data-num="35"></td><td><pre>CODE_SEG equ gdt_code <span class="token operator">-</span> gdt_start</pre></td></tr><tr><td data-num="36"></td><td><pre>DATA_SEG equ gdt_data <span class="token operator">-</span> gdt_start</pre></td></tr></table></figure></div></details><p>上面的代码中其实还隐藏了一个知识点，仔细想想也确实会有一个并不是很合逻辑的地方。我们知道在高级语言，例如 <code>C语言</code> 中，一个一个的创建变量并不能保证变量在内存中是连续存储的，除非用数组；但是我们的代码里面并没有任何的特殊数据结构的形式，那么 <code>GDT</code> 的每一项在内存中是一定在一起的吗？</p><details class="primary"><summary>如果是，那么这代表什么？如果不是，那么实际又是怎么实现的呢？</summary><div><p>答案：<strong>一定是在一起</strong>。这是因为汇编源代码里的指令和数据部分是可以自由混杂排布的，而且最终编译出来的二进制中，它们排布顺序完全遵循源代码的排布。所以你可以任意安排你的指令和数据所处的位置，只需记得要使用各种跳转指令来控制代码运行即可。</p><p>但是，整个 <code>loader</code> 的起始位置，即入口代码必须在 <code>0x9000</code> 处，因为这是和 <code>mbr</code> 约定好的跳转地址（详见<a href="https://gality.cn/os/02-mbr/">上一章</a>），至于后面全部可以自由发挥和排布。</p><p>其实，这个特性又是另外一个问题的答案，不知道有没有读者在看前面的代码时有这么一个疑问，为什么都要在代码结束加上 <code>jmp $</code> ，一定要加吗？</p><p>当然<strong>是的</strong>，这个问题的答案同样是来源于上述特性，如果不加上 <code>jmp $</code> 来使代码进入死循环，那么代码将继续向后执行，将随机乱码理解成代码去执行，这样会导致未知错误。</p></div></details><h2 id="保护模式"><a class="anchor" href="#保护模式">#</a> 保护模式</h2><h3 id="设置gdtr"><a class="anchor" href="#设置gdtr">#</a> 设置 GDTR</h3><p>上一步中我们已经定义了 <code>GDT</code> 和 <code>GDT Descriptor</code> 结构，只需要使用 <code>lgdt [gdt_descriptor]</code> 命令来将 <code>GDT Descriptor</code> 的地址加载到 <code>GDTR</code> 寄存器中即可。</p><h3 id="进入保护模式"><a class="anchor" href="#进入保护模式">#</a> 进入保护模式</h3><p>设置完 <code>GDT</code> 后我们就可以使 CPU 进入保护模式了，进入保护模式非常简单，只需要设置 CPU 的 <code>cr0</code> 寄存器即可。 <code>cr0</code> 寄存器是一个控制寄存器，共 32 位，每一位都对应着不同的控制能力，我们这里无需管其他位的能力，只需要关注第 0 位 PE（Protected Enable）位即可，当 <code>PE=0</code> 时，启动保护模式； <code>PE=1</code> 时，则在实模式运行。</p><p>我们在对 cr0 寄存器进行操作时还必须注意需要保留其他控制位值不变，想到了什么操作？没错，就是 <code>OR</code> ，该操作可以仅将第 0 位改变成 <code>1</code> ，并保持其他位不变。</p><p>还有一点需要注意的是， <code>OR</code> 操作不能直接对 <code>cr0</code> 寄存器进行操作，所以我们需要借助 <code>eax</code> 寄存器来作为桥梁，完成对 <code>cr0</code> 寄存器的赋值，代码是不是已经呼之欲出了？</p><details class="info"><summary>进入保护模式</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>mov <span class="token register variable">eax</span>, <span class="token register variable">cr0</span></pre></td></tr><tr><td data-num="2"></td><td><pre>or <span class="token register variable">eax</span>, <span class="token number">0x1</span> <span class="token comment">; set 32-bit mode bit in cr0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>mov <span class="token register variable">cr0</span>, <span class="token register variable">eax</span></pre></td></tr></table></figure></div></details><p>此时，我们就正式进入保护模式了。</p><h3 id="刷新cpu管道"><a class="anchor" href="#刷新cpu管道">#</a> 刷新 CPU 管道</h3><p>为什么要刷新 CPU 管道（pipeline）呢？是因为 CPU 是以 pipeline 的方式工作的，需要执行的指令都在 pipeline 中，若两个不同指令依赖同一块数据，同时修改这块数据就可能导致危险，这种情况下，就需要刷新 CPU 管道来防止这种危险发生（这里查到的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS9qYXJnb24vcC9waXBlbGluZS1mbHVzaC5odG0jOn46dGV4dD1BJTIwaGF6YXJkJTIwY29uZGl0aW9uJTIwbWF5JTIwcHJlc2VudCxjb3JydXB0ZWQlMjBieSUyMHRoZSUyMHBpcGVsaW5pbmclMjBwcm9jZXNzLg==">资料</span>是这样的，但是感觉稍微有一点点问题，有熟悉的师傅欢迎评论区留言呀～）。</p><p>刷新 CPU 管道也非常简单，可以通过一个远跳命令实现:</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>jmp CODE_SEG:init_pm <span class="token comment">; far jump by using a different segment to refresh pipeline</span></pre></td></tr></table></figure><h3 id="初始化段寄存器"><a class="anchor" href="#初始化段寄存器">#</a> 初始化段寄存器</h3><p>上一章中我们已经介绍了寄存器的默认用法及含义，这里详细介绍下段寄存器各自的用途</p><div class="note info no-icon"><p>在保护模式下，CPU 提供了段寄存器（16 位）。段寄存器存放的并不是段的基地址，而是段选择符（Segment Descriptor）的相对于 GDT 地址的偏移地址（这也是为什么我们在上一节的代码中要定义 <code>CODE_SEG</code> 和 <code>DATA_SEG</code> 的原因），这些段寄存器包括 <code>cs</code> 、 <code>ss</code> 、 <code>ds</code> 、 <code>es</code> 、 <code>fs</code> 、 <code>gs</code> 。前三个寄存器有特定用途：</p><ul><li><strong>cs</strong>：代码段寄存器，指向包含程序指令的段</li><li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段</li><li><strong>ds</strong>：数据段寄存器，指向包含静态数据或全局数据的数据段</li></ul><p>后三个段寄存器是通用的。</p></div><p><code>cs</code> 寄存器直接由 CPU 设置（想想上一章中讲的）我们无需初始化，所以我们就需要初始化其他的寄存器，至于用什么初始化，当然是我们提前定义好的 <code>DATA_SEG</code> 变量啦，有一点需要注意，段寄存器同样也不能直接进行立即数的赋值，我们需要借助 <code>ax</code> （16 位）来帮助赋值。</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">[</span>bits <span class="token number">32</span><span class="token operator">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token label function">init_pm:</span> <span class="token comment">; we are now using 32-bit instructions</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    mov <span class="token register variable">ax</span>, DATA_SEG <span class="token comment">; update the segment registers</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    mov <span class="token register variable">ds</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    mov <span class="token register variable">ss</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mov <span class="token register variable">es</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    mov <span class="token register variable">fs</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    mov <span class="token register variable">gs</span>, <span class="token register variable">ax</span></pre></td></tr></table></figure><h3 id="初始化栈"><a class="anchor" href="#初始化栈">#</a> 初始化栈</h3><p><img data-src="http://imgcdn.gality.cn/blog/k0xq4i.png" alt="mbr工作阶段内存布局"></p><p>还记得上面这个图吗，我们将 <code>loader</code> 的地址设置在了 <code>0x8000</code> 后 <code>0x1000</code> 的空间内，此时 <code>0x8000</code> 前后的空间和 <code>mbr</code> 前的空间都是空着的，我们用 <code>mbr</code> 前面的空间来布置栈，就像示意图中标识的那样，将栈底设置为 <code>0x7B00</code> （栈向低地址增长），代码同样非常简单。</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>mov <span class="token register variable">ebp</span>, <span class="token number">0x7B00</span></pre></td></tr><tr><td data-num="2"></td><td><pre>mov <span class="token register variable">esp</span>, <span class="token register variable">ebp</span></pre></td></tr></table></figure><p>将以上代码合并起来，就形成了从实模式到保护模式的代码</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">[</span>bits <span class="token number">16</span><span class="token operator">]</span> <span class="token comment">; real mode</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token label function">switch_to_pm:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    cli <span class="token comment">; 1. disable interrupts</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    in <span class="token register variable">al</span>, <span class="token number">92h</span> <span class="token comment">; 2. enable A20</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    or <span class="token register variable">al</span>, <span class="token number">00000010b</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    out <span class="token number">92h</span>, <span class="token register variable">al</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    lgdt <span class="token operator">[</span>gdt_descriptor<span class="token operator">]</span> <span class="token comment">; 3. load the GDT descriptor</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    mov <span class="token register variable">eax</span>, <span class="token register variable">cr0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    or <span class="token register variable">eax</span>, <span class="token number">0x1</span> <span class="token comment">; 4. set 32-bit mode bit in cr0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    mov <span class="token register variable">cr0</span>, <span class="token register variable">eax</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    jmp CODE_SEG:init_pm <span class="token comment">; 5. far jump by using a different segment to refresh cpu pipeline</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token operator">[</span>bits <span class="token number">32</span><span class="token operator">]</span> <span class="token comment">; protected mode</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token label function">init_pm:</span> <span class="token comment">; we are now using 32-bit instructions</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    mov <span class="token register variable">ax</span>, DATA_SEG <span class="token comment">; 6. update the segment registers</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    mov <span class="token register variable">ds</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    mov <span class="token register variable">ss</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    mov <span class="token register variable">es</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    mov <span class="token register variable">fs</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    mov <span class="token register variable">gs</span>, <span class="token register variable">ax</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    mov <span class="token register variable">ebp</span>, <span class="token number">0x7B00</span> <span class="token comment">; 7. update the stack right at the top of the free space</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    mov <span class="token register variable">esp</span>, <span class="token register variable">ebp</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    call BEGIN_PM <span class="token comment">; 8. Call a well-known label with useful code</span></pre></td></tr></table></figure><p>此时，我们不妨写一个 main 函数来调用上述过程，然后测试一下程序：</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">[</span>org <span class="token number">0x7c00</span><span class="token operator">]</span> <span class="token comment">; bootloader offset</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    mov <span class="token register variable">bp</span>, <span class="token number">0x9000</span> <span class="token comment">; set the stack</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    mov <span class="token register variable">sp</span>, <span class="token register variable">bp</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    mov <span class="token register variable">bx</span>, MSG_REAL_MODE</pre></td></tr><tr><td data-num="6"></td><td><pre>    call print <span class="token comment">; This will be written after the BIOS messages</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    call switch_to_pm</pre></td></tr><tr><td data-num="9"></td><td><pre>    mov <span class="token register variable">bx</span>, MSG_ERROR <span class="token comment">; this will actually never be executed</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    call print </pre></td></tr><tr><td data-num="11"></td><td><pre>    jmp <span class="token operator">$</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token operator">%</span>include <span class="token string">"../02-mbr/boot-print.asm"</span> <span class="token comment">; must be the first included</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token operator">%</span>include <span class="token string">"32bit-gdt.asm"</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token operator">%</span>include <span class="token string">"32bit-switch.asm"</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token operator">[</span>bits <span class="token number">32</span><span class="token operator">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token label function">BEGIN_PM:</span> <span class="token comment">; after the switch we will get here</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">; need patch</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    jmp <span class="token operator">$</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>MSG_REAL_MODE db <span class="token string">"Started in 16-bit real mode"</span>, <span class="token number">0</span></pre></td></tr><tr><td data-num="23"></td><td><pre>MSG_ERROR db <span class="token string">"Loaded 32-bit protected mode ERROR"</span>, <span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment">; bootsector</span></pre></td></tr><tr><td data-num="26"></td><td><pre>times <span class="token number">510</span><span class="token operator">-</span>(<span class="token operator">$</span><span class="token operator">-</span><span class="token operator">$</span><span class="token operator">$</span>) db <span class="token number">0</span></pre></td></tr><tr><td data-num="27"></td><td><pre>dw <span class="token number">0xaa55</span></pre></td></tr></table></figure><p>然后编译执行就可以了</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>nasm <span class="token parameter variable">-fbin</span> 32bit-main.asm <span class="token parameter variable">-o</span> loader.bin</pre></td></tr><tr><td data-num="2"></td><td><pre>qemu-system-i386 <span class="token parameter variable">-fda</span> loader.bin</pre></td></tr></table></figure><p>实际测试发现 <code>boot-print.asm</code> 必须第一个 include，否则 <code>nasm</code> 在编译的时候会把 <code>[bx]</code> 转换成 <code>[edi]</code> 不知道是 bug 还是我不知道的什么原因，总之，首先 include 就不会有问题了。</p><hr><p>至此，CPU 已经进入了保护模式（32 位），接下来我们需要完成虚拟内存到物理内存的映射，为 kernel 的工作打下基础，由于这部分内容体量相对庞大且至关重要，所以我们放在下下一章详细去讲（下一章先讲点轻松的～）。</p><br><div class="tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 操作系统</a> <a href="/tags/%E7%B3%BB%E5%88%97%E9%95%BF%E7%AF%87/" rel="tag"><i class="ic i-tag"></i> 系列长篇</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8A%9F/" rel="tag"><i class="ic i-tag"></i> 二进制基本功</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-09-21 22:31:17" itemprop="dateModified" datetime="2023-09-21T22:31:17+08:00">2023-09-21</time> </span><span id="os/03-loader/" class="item leancloud_visitors" data-flag-title="03-Loader 编写之进入保护模式" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/wechatpay.png" alt="Gality 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/alipay.png" alt="Gality 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Gality <i class="ic i-at"><em>@</em></i>藏器于身</li><li class="link"><strong>本文链接：</strong> <a href="https://gality.cn/os/03-loader/" title="03-Loader 编写之进入保护模式">https://gality.cn/os/03-loader/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/os/02-mbr/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;imgcdn.gality.cn&#x2F;blog&#x2F;7zx56a.jpg" title="02-从BIOS启动到MBR编写"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 从 0 到 1</span><h3>02-从BIOS启动到MBR编写</h3></a></div><div class="item right"><a href="/misc/trail-and-error/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8GDB/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;imgcdn.gality.cn&#x2F;blog&#x2F;ez3kpx.png" title="Mac下使用GDB进行调试"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 踩坑</span><h3>Mac下使用GDB进行调试</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#loader%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Loader 的工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#loader%E7%BC%96%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">Loader 编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">2.1.</span> <span class="toc-text">禁用中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E8%83%BDa20%E5%9C%B0%E5%9D%80%E7%BA%BF"><span class="toc-number">2.2.</span> <span class="toc-text">使能 A20 地址线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8Bgdt"><span class="toc-number">2.3.</span> <span class="toc-text">建立 GDT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gdtr"><span class="toc-number">2.3.1.</span> <span class="toc-text">GDTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdt"><span class="toc-number">2.3.2.</span> <span class="toc-text">GDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asm"><span class="toc-number">2.3.3.</span> <span class="toc-text">asm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEgdtr"><span class="toc-number">2.4.1.</span> <span class="toc-text">设置 GDTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">进入保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0cpu%E7%AE%A1%E9%81%93"><span class="toc-number">2.4.3.</span> <span class="toc-text">刷新 CPU 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">初始化段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88"><span class="toc-number">2.4.5.</span> <span class="toc-text">初始化栈</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/os/00-preface/" rel="bookmark" title="序言-操作系统从0到1">序言-操作系统从0到1</a></li><li><a href="/os/01-environment/" rel="bookmark" title="01-环境准备">01-环境准备</a></li><li><a href="/os/02-mbr/" rel="bookmark" title="02-从BIOS启动到MBR编写">02-从BIOS启动到MBR编写</a></li><li class="active"><a href="/os/03-loader/" rel="bookmark" title="03-Loader编写之进入保护模式">03-Loader编写之进入保护模式</a></li><li><a href="/os/04-32bit-print/" rel="bookmark" title="04-在保护模式下打印">04-在保护模式下打印</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Gality" data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/avatar.png"><p class="name" itemprop="name">Gality</p><div class="description" itemprop="description">安全杂记 & 日常随感</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">54</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dhbGl0eTM2OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Gality369"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <a href="https://gality.cn/about/" title="https:&#x2F;&#x2F;gality.cn&#x2F;about&#x2F;" class="item about"><i class="ic i-address-card"></i></a> <span class="exturl item email" data-url="bWFpbHRvOjQzNDQwMDcyNkBxcS5jb20=" title="mailto:434400726@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>小伙伴</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>资源</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/os/02-mbr/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/misc/trail-and-error/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8GDB/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/0-1/" title="分类于 从 0 到 1">从 0 到 1</a></div><span><a href="/os/01-environment/" title="01-环境准备">01-环境准备</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/scientific-research/" title="分类于 科研">科研</a> <i class="ic i-angle-right"></i> <a href="/categories/scientific-research/thesis-reading/" title="分类于 论文阅读">论文阅读</a></div><span><a href="/scientific-research/thesis-reading/JANUS/" title="论文阅读｜ Fuzzing File Systems via Two-Dimensional Input Space Exploration">论文阅读｜ Fuzzing File Systems via Two-Dimensional Input Space Exploration</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/kernel/" title="分类于 内核">内核</a></div><span><a href="/os/kernel/build-kernel/" title="从0开始构建Linux内核">从0开始构建Linux内核</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8GDB/" title="Mac下使用GDB进行调试">Mac下使用GDB进行调试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ml/" title="分类于 机器学习">机器学习</a></div><span><a href="/ml/transformer/" title="Transformer 详解">Transformer 详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/tool-usage/" title="分类于 工具使用">工具使用</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/tool-usage/GDB/" title="分类于 GDB">GDB</a></div><span><a href="/misc/tool-usage/GDB-with-QEMU/" title="GDB+QEMU调试mbr&#x2F;loader">GDB+QEMU调试mbr/loader</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/conda-mamba/" title="机器学习-环境搭建踩坑-conda&amp;mamba">机器学习-环境搭建踩坑-conda&mamba</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ponder/" title="分类于 思考与沉淀">思考与沉淀</a></div><span><a href="/ponder/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/" title="科技协会面试反思与总结">科技协会面试反思与总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/fs/" title="分类于 文件系统">文件系统</a></div><span><a href="/os/fs/FAT32/" title="文件系统详解 ｜ FAT32">文件系统详解 ｜ FAT32</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/fs/" title="分类于 文件系统">文件系统</a></div><span><a href="/os/fs/VFS/" title="Linux 文件系统模型与VFS入门">Linux 文件系统模型与VFS入门</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Gality @ Samadhi</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">253k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">7:40</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"os/03-loader/",favicon:{show:"（●´3｀●）哎呀呀～",hide:"(´Д｀)吓死你"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/js/app.js?v=0.2.5"></script></body></html>