<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="KbCOz5IFs80bU-psVUCv9C7SOLzVWto8d7_5ZSsX7I0"><meta name="baidu-site-verification" content="codeva-KcLqIZYGXd"><link rel="alternate" type="application/rss+xml" title="藏器于身" href="https://gality.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="藏器于身" href="https://gality.cn/atom.xml"><link rel="alternate" type="application/json" title="藏器于身" href="https://gality.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/css/app.css?v=0.2.5"><meta name="keywords" content="操作系统,os,从零开始,boot,bios,nasm"><link rel="canonical" href="https://gality.cn/os/02-mbr/"><title>02 - 从 BIOS 启动到 MBR 编写 - 从 0 到 1 - 操作系统 | Samadhi = 藏器于身 = 待时而动</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">02 - 从 BIOS 启动到 MBR 编写</h1><div class="meta"><span class="item" title="创建时间：2023-08-22 12:03:46"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-22T12:03:46+08:00">2023-08-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Samadhi</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://imgcdn.gality.cn/blog/xgchi3.png"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/065frw.jpg"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/mhbs22.jpg"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/10s606.png"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/2023-08-19-wallhaven-j3m8y5_1920x1080.png"></li><li class="item" data-background-image="http://imgcdn.gality.cn/blog/8ji8mr.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/os/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/os/0-1/" itemprop="item" rel="index" title="分类于 从 0 到 1"><span itemprop="name">从 0 到 1</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://gality.cn/os/02-mbr/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/avatar.png"><meta itemprop="name" content="Gality"><meta itemprop="description" content="待时而动, 安全杂记 & 日常随感"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="藏器于身"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>本章是操作系统从 0 到 1 系列的第三篇文章，主要讲解了计算机从通电到启动操作系统前的过程。在本章中，我将会介绍引导启动中的核心概念和知识，并最终自己实现一个 MBR。</p></div><div class="note warning"><p><em>Concepts you may want to Google beforehand: assembler, BIOS, BOOT, Real mode, interrupts, CPU registers, control structures, function calling, strings</em></p></div><h1 id="bios和boot"><a class="anchor" href="#bios和boot">#</a> BIOS 和 BOOT</h1><p>即使不了解计算机的人也可能对于 <code>boot</code> 和 <code>bios</code> 这两个词有所耳闻，然而即使是计算机专业的人也可能会混淆这两者的概念，这里我们先来区分一下这两个概念，以便于我们后续的展开。</p><ul><li><ins class="wavy">BIOS</ins> 是英文 &quot;Basic Input Output System&quot; 的缩略语，直译过来后中文名称就是 &quot;基本输入输出系统&quot;。它是一组固化到计算机内主板上一个<strong> ROM 芯片</strong>上的程序，由主板的制造厂商编写代码；我们有时听到的 “刷 BIOS” 就是指将主版上的 BIOS 程序进行更换。</li><li><ins class="wavy">BOOT</ins> 其实是指 <code>Boot Loader</code> ，boot 本身就是 “引导” 的意思，是指一种用来引导操作系统激活的程序，广泛应用于各种系统之中。</li></ul><h2 id="对比"><a class="anchor" href="#对比">#</a> 对比</h2><p>BIOS 保存着计算机最重要的<strong>基本输入输出程序</strong>、<strong>系统设置信息</strong>、<strong>开机后自检程序</strong>和<strong>系统自启动程序</strong>，其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。可从 CMOS 中读写系统设置的具体信息。</p><p>当按下电脑开机键的一瞬间，CPU 会先被激活去寻找 BIOS，接着 BIOS 会先在 Flash Memory 中执行，初始化计算机各种硬件并检测完整性，再执行 CMOS 中用户所喜好的设置，然后 BIOS 将自己解压缩到计算机的主存储器中。再启动引导程序 boot，然后由 boot 将操作系统加载到内存中执行。</p><p>Boot 的过程其实就是由 <code>mbr</code> + <code>loader</code> 一起实现的，后面会详细讲解什么是 <code>mbr</code> ，什么是 <code>loader</code> ，耐心看下去吧～</p><h1 id="mbr实现"><a class="anchor" href="#mbr实现">#</a> MBR 实现</h1><p>尽管很多教程中直接提供了 <code>mbr</code> 和 <code>loader</code> 供我们使用而无需自己编写，但是我仍推荐至少自行实现一次这两者，原因如下；</p><ul><li>有助于提高汇编能力，这一点在后面也至关重要。</li><li>它的编写并不困难，可以借助 <code>mbr</code> + <code>loader</code> 的编写来入门操作系统的编写。</li><li>从 CPU 通电开始写起有助于建立对于计算机的全面认知，为后面的内核、可执行程序的加载，以及虚拟内存的建立做好准备。</li><li>boot 阶段会初步搭建起 segment 以及虚拟内存的框架，为后续 kernel 编写打下基础</li></ul><p>💗真是激动人心，我们要开始编写自己的 <code>mbr</code> 了！</p><h2 id="从通电开始"><a class="anchor" href="#从通电开始">#</a> 从通电开始</h2><p>一个经典的问题：<span class="orange">计算机通电后是怎么就进入到了操作系统呢？</span></p><p>计算机通电后，CPU 处于<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlOUUlRTYlQTglQTElRTUlQkMlOEYvNzM1NDUzMQ==">实模式</span>，在实模式下，CPU 寻址方式为：由 16 位段寄存器值 * 10H 加 16 位偏移地址来形成 20 位的寻址空间，即只有 1M 的空间是可以被 CPU 读取的，而其他空间 CPU 都无法使用，CPU 必须借助这 1M 空间内的存储的各种程序来引导操作系统启动。</p><details class="primary"><summary>为什么是20位寻址空间呢？</summary><div><p>这与 CPU 的发展历史有关，在 CPU 早期 (8086 时期)，由于 CPU 性能有限，一共只有 20 位地址线，可寻址空间只有 1M (2<sup>20</sup> bytes)，以及 8 个 16 位的通用寄存器，和 4 个 16 位的段寄存器；16 位的物理地址只能访问 64KB (2<sup>16</sup> bytes) 的内存。所以，为了能够通过这些 16 位的寄存器去构成 20 位的寻址地址，访问 1 MB 的内存，必须采取一种特殊的方式。</p><p>特殊方式即由 <code>段基址 + 段内偏移</code> 的方式来将 16 位的地址扩展为 20 位，具体方式如下：</p><ul><li>段基址：由段寄存器提供，并将寄存器值左移 4 位，将结果作为基地址。</li><li>段内偏移地址：由通用寄存器来提供 (如 EIP)</li></ul><p>将二者相加，得到一个 20 位的地址，覆盖 CPU 20 位的寻址空间，这里给出一个例子以便于更形象的说明：</p><p>例如，段基址为 <code>0x1000</code> ，段内偏移为 <code>0x1234</code> ，则此时物理地址可以由下式计算得出：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mi>x</mi><mn>1000</mn><mo>&lt;</mo><mo>&lt;</mo><mn>4</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>10000</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>1234</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>11234</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin {array}{c} 0x1000 &lt;&lt; 4 + 0x1234 = 0x10000 + 0x1234 = 0x11234 \end {array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-.35000000000000003em"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8500000000000001em"><span style="top:-3.01em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mord">3</span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.35000000000000003em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span></span></span></span></span></span></span></p></div></details><p>因此，这至关重要的 1MB 空间的划分是已经固定好的，每一块都有规定的用途的，被映射到不同的设备上：</p><p><img data-src="http://imgcdn.gality.cn/blog/vj8uwa.png" alt="实模式下1M寻址空间分配表"></p><h2 id="bios的工作"><a class="anchor" href="#bios的工作">#</a> BIOS 的工作</h2><p>我们前面提到，CPU 通电后，将会执行 BIOS 程序，那么 BIOS 具体的工作有哪些呢？包括以下几步：</p><ol><li>开机后 CPU 的指令寄存器 <code>EIP</code> 被设置为地址 <code>0xFFFF0</code> ，这一地址指向 BIOS 固件上的代码，CPU 从这里执行开机后的第一条指令；</li><li>CPU 开始执行 BIOS 上的代码，这一部分主要是硬件输入输出设备相关的检查，以及建立一个最初的中断向量表（后面会提到）；</li><li>BIOS 代码最后阶段的工作，就是检查启动盘上的 <code>mbr</code> 分区，所谓 mbr 分区就是指磁盘上的第一个 512 bytes 的内容，又叫 <code>引导分区</code> ；BIOS 会对这 512 bytes 做一个检查：它的最后 2 个字节必须是特定的两个 magic number： <code>0x55</code> 和 <code>0xaa</code> ，否则它就不是一个合法的启动盘；</li><li>检查通过后，BIOS 将这 512B 加载到内存 <code>0x7C00</code> 处，到 0x7E00 为止，然后指令跳转到 0x7C00 开始执行；至此 BIOS 退出舞台；</li></ol><p>我们可以将这个过程画成一个图，来帮助我们理解</p><p><img data-src="http://imgcdn.gality.cn/blog/a4r89b.png" alt=""></p><ul><li>黄色部分是 <code>mbr</code> ，被 bios 从磁盘复制到内存中去执行</li><li>粉色部分是 <code>bios</code> 代码</li><li>黄色部分的两边的白色部分 (0x500 开始) 是我们可以自由使用的空间</li></ul><h2 id="mbr的工作"><a class="anchor" href="#mbr的工作">#</a> mbr 的工作</h2><p><code>mbr</code> 的大小被限制在了 512 bytes，这对于引导一个操作系统的重任来说有点太小了，里面根本放不下太多的数据和代码，所以 <code>mbr</code> 的工作其实只是将一个 <code>laoder</code> 加载到内存，然后跳转到 <code>loader</code> 去继续执行。</p><p>我们还是用一个示意图来表示这个过程的变化和内存布局：</p><p><img data-src="http://imgcdn.gality.cn/blog/k0xq4i.png" alt="mbr工作阶段内存布局"></p><p>「假设我们把 <code>loader</code> 加载到 <code>0x8000</code> 处（可以任意指定加载的位置，只需要 <code>mbr</code> 中对应起来就可以）， <code>loader</code> 大约 4KB 大小」</p><p>上一节中我们说过， <code>mbr</code> 被加载到内存后，前后都有一块可供我们自由使用的空间，前面那块 (0x500 开始) 较小，大约 30KB，而后面这块 (0x7E00 开始) 就大的多了，大约有 608KB 左右的空间，我们就可以利用这块内存空间，将 <code>loader</code> 加载进内存并执行。</p><h2 id="牛刀小试"><a class="anchor" href="#牛刀小试">#</a> 牛刀小试</h2><p>理论知识已经学了很多了，但是直接就开始写一个完整 <code>mbr</code> 还是有点难度的，不如我们从 <code>hello world</code> 开始。</p><div class="note default"><p>🎯编写一个 mbr，并打印 'Hello World!'</p></div><p>原理：通过<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSU5UXzEwSA=="> 0x10H 中断</span>触发 bios 中的打印服务，向屏幕输出字符，该中断的调用规则为：</p><table><thead><tr><th>Teletype output</th><th>AH=0Eh</th><th>AL = Character, BH = Page Number, BL = <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQklPU19Db2xvcl9BdHRyaWJ1dGVz">Color</span> (only in graphic mode)</th><th>no return</th></tr></thead></table><p>然后我们就可以编写代码了：</p><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre>mov <span class="token register variable">ah</span>, <span class="token number">0x0e</span> <span class="token comment">; set tty mode</span></pre></td></tr><tr><td data-num="2"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'H'</span></pre></td></tr><tr><td data-num="3"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="4"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'e'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="6"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'l'</span></pre></td></tr><tr><td data-num="7"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="8"></td><td><pre>int <span class="token number">0x10</span> <span class="token comment">; 'l' is still on al</span></pre></td></tr><tr><td data-num="9"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'o'</span></pre></td></tr><tr><td data-num="10"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="11"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">' '</span></pre></td></tr><tr><td data-num="12"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="13"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'W'</span></pre></td></tr><tr><td data-num="14"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="15"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'o'</span></pre></td></tr><tr><td data-num="16"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="17"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'r'</span></pre></td></tr><tr><td data-num="18"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="19"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'l'</span></pre></td></tr><tr><td data-num="20"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="21"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'d'</span></pre></td></tr><tr><td data-num="22"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="23"></td><td><pre>mov <span class="token register variable">al</span>, <span class="token string">'!'</span></pre></td></tr><tr><td data-num="24"></td><td><pre>int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>jmp <span class="token operator">$</span><span class="token comment">;  jump to current address = infinite loop</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>times <span class="token number">510</span> <span class="token operator">-</span> (<span class="token operator">$</span><span class="token operator">-</span><span class="token operator">$</span><span class="token operator">$</span>) db <span class="token number">0</span> <span class="token comment">; fill with 0,length = (510 - previous code)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>dw <span class="token number">0xaa55</span> <span class="token comment">; x86 is little-endian</span></pre></td></tr></table></figure><div class="note info no-icon"><p>nasm 语法：</p><ul><li><code>$</code> ：当前行在所在段的相对位移</li><li><code>$$</code> ：当前段的起始地址</li><li><code>dd</code> ：即 <code>define double</code> ，定义一个 4 字节值</li><li><code>dw</code> ：即 <code>define word</code> ，定义一个 2 字节值</li><li><code>db</code> ：即 <code>define byte</code> ，定义一个 1 字节值</li></ul></div><p>我们把上面的代码保存成 <code>boot_hello_world.asm</code> , 然后用 <code>nasm</code> 编译他：</p><p><code>nasm -fbin boot_hello_world.asm -o boot_hello_world.bin</code></p><p>然后你就可以通过 <code>xxd</code> 来查看生成的 <code>bin</code> 文件:</p><p><img data-src="http://imgcdn.gality.cn/blog/szjute.jpg" alt="xxd of bin file" height="561" width="478"></p><p>我们可以看到，结尾时 Magic Number <code>0x55aa</code> ，前面是我们写的 asm 代码转成的机器码，中间用 0 填充，一共 <code>0x200</code> 也就是 512bytes。</p><p>接着就可以用 qemu 来执行他了</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># mac</span></pre></td></tr><tr><td data-num="2"></td><td><pre>qemu-system-i386 boot_hello_world.bin</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># linux</span></pre></td></tr><tr><td data-num="5"></td><td><pre>qemu boot_hello_world.bin</pre></td></tr></table></figure><p>不出意外的话，你就会看到 <code>Hello World!</code> 了🎉</p><p><img data-src="http://imgcdn.gality.cn/blog/q8kecc.png" alt="qemu with hello world"></p><h3 id="problem-time"><a class="anchor" href="#problem-time">#</a> Problem Time</h3><ol><li class="quiz"><p>以下哪行代码可以使 <code>Hello World!</code> 以绿色字体输出：</p><ul class="options"><li><code>mov bl, 0x0a</code></li><li><code>mov bh, 0x0a</code></li><li><code>mov bl, 0x0c</code></li><li class="correct">以上都不对</li></ul><blockquote><ul class="options"><li>该设置只有在图形化模式下才生效</li><li>需设置 bl 才能影响输出字符颜色</li><li>根据手册 10 才是绿色对应的代码</li></ul></blockquote></li></ol><h2 id="更进一步打印信息"><a class="anchor" href="#更进一步打印信息">#</a> 更进一步 (打印信息)</h2><p>上面我们已经学会了打印字符，那么接下来我们尝试编写几个打印函数用于输出错误或信息，帮助我们在后面的过程中定位问题。</p><h3 id="打印新行"><a class="anchor" href="#打印新行">#</a> 打印新行</h3><p>先简单一点，我们写一个打印换行符的函数 <code>print_nl()</code> ，其实就是依次打印 ascii 表特殊字符中的换行符，很简单，做一点点解释</p><ul><li><p><code>\r</code> ：对应 ascii 码为 13 的字符，表示回车，将当前位置移到本行头</p></li><li><p><code>\n</code> ：对应 ascii 码为 10 的字符，表示换行，将当前位置移动到下一行</p></li></ul><details class="info"><summary>print_nl()</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">; print a new line</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token label function">print_nl:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    pusha</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    mov <span class="token register variable">ah</span>, <span class="token number">0x0e</span> <span class="token comment">; tty mode</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mov <span class="token register variable">al</span>, <span class="token number">0x0a</span> <span class="token comment">; '\r'</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    mov <span class="token register variable">al</span>, <span class="token number">0x0d</span> <span class="token comment">; '\n'</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    int <span class="token number">0x10</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    popa</pre></td></tr><tr><td data-num="12"></td><td><pre>    ret</pre></td></tr></table></figure></div></details><h3 id="打印字符串"><a class="anchor" href="#打印字符串">#</a> 打印字符串</h3><p>然后加大一点难度，通过循环来实现一个打印字符串的函数 <code>print()</code> ，本质就是一个一个的打印字符，一些要点如下：</p><ul><li>因为调用 <code>print()</code> 的场景是程序运行过程中，所以函数开始要 <code>pusha</code> 保存 “现场”，在调用结束前还需要用 <code>popa</code> 还原 “现场”</li><li>通过 <code>bx</code> 寄存器来传递参数 (寄存器有<span class="exturl" data-url="aHR0cHM6Ly93d3cudHV0b3JpYWxzcG9pbnQuY29tL2Fzc2VtYmx5X3Byb2dyYW1taW5nL2Fzc2VtYmx5X3JlZ2lzdGVycy5odG0=">默认的用法</span>，这里推荐用 <code>bx</code> 来传递参数)</li><li>可以通过 <code>cmp</code> 和 <code>je</code> 命令来进行条件判断和分支跳转。</li></ul><details class="info"><summary>print( [bx]string s )</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">; print a string pointed with bx</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token label function">print:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    pusha</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">; keep this in mind:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">; while (string[i] != 0) &#123; print string[i]; i++ &#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">; the comparison for string end (null byte)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token label function">print_start:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    mov <span class="token register variable">al</span>, <span class="token operator">[</span><span class="token register variable">bx</span><span class="token operator">]</span> <span class="token comment">; 'bx' is the base address for the string</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cmp <span class="token register variable">al</span>, <span class="token number">0</span> <span class="token comment">; if '\0', then stop loop</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    je print_end</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">; the part where we print with the BIOS help</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    mov <span class="token register variable">ah</span>, <span class="token number">0x0e</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    int <span class="token number">0x10</span> <span class="token comment">; 'al' already contains the char</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">; increment pointer and do next loop</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    add <span class="token register variable">bx</span>, <span class="token number">1</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    jmp print_start</pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token label function">print_end:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    popa</pre></td></tr><tr><td data-num="24"></td><td><pre>    ret</pre></td></tr></table></figure></div></details><h3 id="以十六进制打印数字"><a class="anchor" href="#以十六进制打印数字">#</a> 以十六进制打印数字</h3><p>同样的道理，我们来将数字以 16 进制打印出来，由于我们直接是直接对接底层 CPU 的处理，没有现成的进制转换函数供我们使用，此时我们需要自己处理进制转换（数字到字符）和格式化输出，步骤如下：</p><ol><li>参数：通过 <code>dx</code> 寄存器来传递参数</li><li>预处理：用寄存器来记录需要被转换的值，寄存器为 16 位，每次处理 4 位（一个 16 进制字符），所以要建立一个循环 4 次的函数</li><li>取数字：可以通过和 <code>0x000f</code> 进行 <code>与操作</code> 的方式，来仅取出 4 位数，方便后续处理</li><li>进制转换：原数字 + <code>0x30</code> 就会转换成对应的数字的字符，与 9 做比较，如果更大，就加 7（对应 ascii 表的 <code>A</code> -&gt; <code>F</code> ）</li><li>格式化处理：结合索引，通过移位的方式来将字符放在合适的位置，</li><li>打印：调用上面写的 <code>print()</code> 函数</li></ol><p><span class="wavy">注意</span>：字符串在定义时末尾必须加上 <code>0</code> ，来作为字符串结束的标识（例如 <code>HEX_OUT</code> ）</p><details class="info"><summary>print_hex( [dx]number n )</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">; receiving the data in 'dx'</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">; For the examples we'll assume that we're called with dx=0x1234</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token label function">print_hex:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    pusha</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    mov <span class="token register variable">cx</span>, <span class="token number">0</span> <span class="token comment">; our index variable</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">; Strategy: get the last char of 'dx', then convert to ASCII</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">; Numeric ASCII values: '0' (ASCII 0x30) to '9' (0x39), so just add 0x30 to byte N.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">; For alphabetic characters A-F: 'A' (ASCII 0x41) to 'F' (0x46) we'll add 0x40</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">; Then, move the ASCII byte to the correct position on the resulting string  </span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token label function">print_hex_start:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cmp <span class="token register variable">cx</span>, <span class="token number">4</span> <span class="token comment">; loop 4 times</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    je print_hex_end</pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">; 1. convert last char of 'dx' to ascii</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    mov <span class="token register variable">ax</span>, <span class="token register variable">dx</span> <span class="token comment">; we will use 'ax' as our working register</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    and <span class="token register variable">ax</span>, <span class="token number">0x000f</span> <span class="token comment">; 0x1234 -> 0x0004 by masking first three to zeros</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    add <span class="token register variable">al</span>, <span class="token number">0x30</span> <span class="token comment">; add 0x30 to N to convert it to ASCII "N"</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    cmp <span class="token register variable">al</span>, <span class="token number">0x39</span> <span class="token comment">; if > 9, add extra 8 to represent 'A' to 'F'</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    jle step2</pre></td></tr><tr><td data-num="22"></td><td><pre>    add <span class="token register variable">al</span>, <span class="token number">0x07</span> <span class="token comment">; 'A' is ASCII 65 instead of 58, so 65-58=7</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token label function">step2:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">; 2. get the correct position of the string to place our ASCII char</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">; bx &lt;- base address + string length - index of char</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    mov <span class="token register variable">bx</span>, hex_string <span class="token operator">+</span> <span class="token number">5</span> <span class="token comment">; base + length</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    sub <span class="token register variable">bx</span>, <span class="token register variable">cx</span> <span class="token comment">; our index variable</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    mov <span class="token operator">[</span><span class="token register variable">bx</span><span class="token operator">]</span>, <span class="token register variable">al</span> <span class="token comment">; copy the ASCII char on 'al' to the position pointed by 'bx'</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    ror <span class="token register variable">dx</span>, <span class="token number">4</span> <span class="token comment">; 0x1234 -> 0x4123 -> 0x3412 -> 0x2341 -> 0x1234</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">; increment index and loop</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    add <span class="token register variable">cx</span>, <span class="token number">1</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    jmp print_hex_start</pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token label function">print_hex_end:</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token comment">; prepare the parameter and call the function</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token comment">; remember that print receives parameters in 'bx'</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    mov <span class="token register variable">bx</span>, hex_string</pre></td></tr><tr><td data-num="40"></td><td><pre>    call print</pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>    popa</pre></td></tr><tr><td data-num="43"></td><td><pre>    ret</pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token label function">hex_string:</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    db <span class="token string">'0x0000'</span>, <span class="token number">0</span> <span class="token comment">; reserve memory for our new string</span></pre></td></tr></table></figure></div></details><p>完成以上打印函数后，我们可以将他们保存在 <code>print.nasm</code> 中，然后通过 <code>%include &quot;boot_print.asm&quot;</code> 的方式在别的 <code>asm</code> 中使用我们定义好的打印函数</p><h2 id="一步登天"><a class="anchor" href="#一步登天">#</a> 一步登天</h2><p><s class="danger">好了，现在你已经学会 1+1 了，现在请计算 9.121*7.32/6.97 吧</s></p><p>根据我们之前说的，仔细想想，编写的 <code>mbr</code> 的功能，拆解一下其实并不复杂，本质就是读取一块硬盘，并将 <code>loader</code> 加载到内存中，然后跳转到 <code>loader</code> 执行就可以了，稍微复杂的点在于，由于历史原因，读磁盘时采用的是 CHS 的模式，这点也你会在后面更近一步学习，接着往下看吧。</p><p>「以下代码的部分希望读者能自己根据原理完成，如果觉得较为困难，可以打开折叠栏查看」</p><h3 id="nasm读硬盘"><a class="anchor" href="#nasm读硬盘">#</a> nasm 读硬盘</h3><p>好消息是我们无需去直接跟磁盘打交道，bios 中同样写好了读写磁盘的程序，我们只需要跟打印程序一样通过中断来调用即可。我么可以通过<span class="exturl" data-url="aHR0cHM6Ly9zdGFuaXNsYXZzLm9yZy9oZWxwcGMvaW50XzEzLTIuaHRtbA=="> 0x13H 中断</span>来读写磁盘，该中断的调用参数为：</p><table><thead><tr><th style="text-align:center">Register</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">AH</td><td style="text-align:center">02H =&gt; bios 磁盘服务程序中的读磁盘程序</td></tr><tr><td style="text-align:center">AL</td><td style="text-align:center">要读的扇区个数	(1-128 dec.)</td></tr><tr><td style="text-align:center">CH</td><td style="text-align:center">磁道号的低 8 位 (0-1023 dec.)</td></tr><tr><td style="text-align:center">CL</td><td style="text-align:center">低 5 位为所读起始扇区号， 6-7 位表示磁道号的高 2 位 (1-17 dec.)</td></tr><tr><td style="text-align:center">DH</td><td style="text-align:center">所读磁盘的磁头号 (0-15 dec.)</td></tr><tr><td style="text-align:center">DL</td><td style="text-align:center">需要进行读操作的驱动器号 (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)</td></tr><tr><td style="text-align:center">ES:BX</td><td style="text-align:center">缓冲区地址</td></tr></tbody></table><p>返回值为：</p><table><thead><tr><th style="text-align:center">Register</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">AH</td><td style="text-align:center">status (see INT 13,STATUS)</td></tr><tr><td style="text-align:center">AL</td><td style="text-align:center">number of sectors read</td></tr><tr><td style="text-align:center">CF</td><td style="text-align:center">0 = successful OR 1 = error</td></tr></tbody></table><p>在 mbr 启动的时候，CPU 处于实模式，此时只能使用 bios 按 CHS 的寻址方式来找到 <code>loader</code> 的位置。</p><details class="primary"><summary>CHS到底是什么呢？</summary><div><p>CHS 即 (Cylinder/Head/Sector)，是非常古老的硬盘参数了，很久以前，硬盘的容量还很小，人们采用类似软盘的结构生产硬盘，即硬盘盘片的每一条磁道都具有相同的扇区数，由此产生了磁头数 (Heads)，柱面数 (Cylinders)，扇区数 (Sectors) 以及相应的寻址方式.</p><p>其中:</p><ul><li>磁头数 (Heads)：表示硬盘总共有几个磁头，也就是有几面盘片，最大为 255 (用 8 个二进制位存储);</li><li>柱面数 (Cylinders)：表示硬盘每一面盘片上有几条磁道，最大为 1023 (用 10 个二进制位存储) =&gt; 每条磁道都有编号，叫做磁道号；</li><li>扇区数 (Sectors)：表示每一条磁道上有几个扇区，最大为 63 (用 6 个二进制位存储).</li></ul><p>每个扇区一般是 512 个字节，理论上讲这不是必须的，但好象没有取别的值的。</p><p>因此，数据寻址方式为：先找到磁头，然后再通过柱面和扇区来确定唯一一个磁道，磁道中记录了数据。（如果你想了解<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3lsaW5kZXItaGVhZC1zZWN0b3I=">更多有关早期硬盘的知识</span>）</p></div></details><h4 id="参数值讲解"><a class="anchor" href="#参数值讲解">#</a> 参数值讲解</h4><table><thead><tr><th style="text-align:center">Register</th><th style="text-align:center">Value</th><th style="text-align:center">Remark</th></tr></thead><tbody><tr><td style="text-align:center">AL</td><td style="text-align:center">0x02</td><td style="text-align:center">要读两个扇区 (根据实际情况)</td></tr><tr><td style="text-align:center">CH</td><td style="text-align:center">0x0</td><td style="text-align:center">仍然是 0 号磁道，只不过是去读第二个扇区)</td></tr><tr><td style="text-align:center">CL</td><td style="text-align:center">0x02</td><td style="text-align:center"><code>mbr</code> 总是在 <code>fisrt of cylinder 0 of head 0 of hdd 0</code> ，因此任何字节都只能在第二个扇区之后</td></tr><tr><td style="text-align:center">DH</td><td style="text-align:center">0x00</td><td style="text-align:center">读取第一个磁头 (即第一个盘片)</td></tr><tr><td style="text-align:center">DL</td><td style="text-align:center"></td><td style="text-align:center">由 bios 自动设置</td></tr></tbody></table><p>我们这里先将读磁盘内容的命令封装成一个函数，同时增加一点错误输出函数来帮助我们定位可能存在的错误</p><details class="info"><summary>disk_load([dh]sector n)</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">; load 'dh' sectors from drive 'dl' into ES:BX</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token label function">disk_load:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		pusha</pre></td></tr><tr><td data-num="4"></td><td><pre>		</pre></td></tr><tr><td data-num="5"></td><td><pre>		push <span class="token register variable">dx</span> <span class="token comment">; store the argument in 'dh'</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		</pre></td></tr><tr><td data-num="7"></td><td><pre>		mov <span class="token register variable">ah</span>, <span class="token number">0x02</span> <span class="token comment">; 0x02 = 'read disk'</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		mov <span class="token register variable">al</span>, <span class="token register variable">dh</span> <span class="token comment">; al &lt;- number of sectors to read (0x01 .. 0x80)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		mov <span class="token register variable">cl</span>, <span class="token number">0x02</span> <span class="token comment">; cl &lt;- sector (0x01 .. 0x11)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		mov <span class="token register variable">ch</span>, <span class="token number">0x00</span> <span class="token comment">; ch &lt;- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		mov <span class="token register variable">dh</span>, <span class="token number">0x00</span> <span class="token comment">; dh &lt;- head number (0x0 .. 0xF)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		</pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token comment">; [es:bx] &lt;- pointer to buffer where the data will be stored</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">; caller sets it up for us, and it is actually the standard location for int 13h</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    int <span class="token number">0x13</span>      <span class="token comment">; BIOS interrupt</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    jc disk_error <span class="token comment">; if error (stored in the carry bit)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    pop <span class="token register variable">dx</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cmp <span class="token register variable">al</span>, <span class="token register variable">dh</span>    <span class="token comment">; BIOS also sets 'al' to the # of sectors read. Compare it.</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    jne sectors_error</pre></td></tr><tr><td data-num="21"></td><td><pre>    popa</pre></td></tr><tr><td data-num="22"></td><td><pre>    ret</pre></td></tr><tr><td data-num="23"></td><td><pre>    </pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token label function">disk_error:</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    mov <span class="token register variable">bx</span>, DISK_ERROR</pre></td></tr><tr><td data-num="26"></td><td><pre>    call print</pre></td></tr><tr><td data-num="27"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num="28"></td><td><pre>    mov <span class="token register variable">dh</span>, <span class="token register variable">ah</span> <span class="token comment">; ah = error code, dl = disk drive that dropped the error</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    call print_hex <span class="token comment">; check out the code at http://stanislavs.org/helppc/int_13-1.html</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    jmp disk_loop</pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token label function">sectors_error:</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    mov <span class="token register variable">bx</span>, SECTORS_ERROR</pre></td></tr><tr><td data-num="34"></td><td><pre>    call print</pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token label function">disk_loop:</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    jmp <span class="token operator">$</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token label function">DISK_ERROR:</span> db <span class="token string">"Disk read error"</span>, <span class="token number">0</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token label function">SECTORS_ERROR:</span> db <span class="token string">"Incorrect number of sectors read"</span>, <span class="token number">0</span></pre></td></tr></table></figure></div></details><p>此时还没有结束，让我们写一个 <code>main</code> 函数在将所有之前写的功能串联起来吧，注意这里还有如下几点需要注意：</p><ul><li>开头要加上 <code>[org 0x7c00]</code> ，该命令会将后续出现的所有地址在寻址时加上该偏移，因为这里才是 <code>mbr</code> 真实执行的地址，也即我们各种数据储存的 “基地址”，如果不加的话，在寻址时会出现错误。</li><li>在安全的位置设置我们自己的堆栈</li><li>记得要设置 <code>bx</code> 寄存器指向 <code>loader</code> 的加载地址（因为 <code>es:bx</code> 指向读取出的硬盘数据的存储位置）</li><li>由于我们还没有写 <code>loader</code> ，可以暂时先将 <code>sector 2</code> 设置成某特殊字符，来检验读取效果</li></ul><details class="info"><summary>main.asm</summary><div><figure class="highlight nasm"><figcaption data-lang="NASM"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">[</span>org <span class="token number">0x7c00</span><span class="token operator">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    mov <span class="token register variable">bp</span>, <span class="token number">0x7B00</span> <span class="token comment">; set the stack safely away from us</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    mov <span class="token register variable">sp</span>, <span class="token register variable">bp</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    mov <span class="token register variable">bx</span>, <span class="token number">0x8000</span> <span class="token comment">; es:bx = 0x0000:0x8000 = 0x08000</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mov <span class="token register variable">dh</span>, <span class="token number">2</span> <span class="token comment">; read 2 sectors</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">; the bios sets 'dl' for our boot disk number</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">; if you have trouble, use the '-fda' flag: 'qemu-system-i386 -fda file.bin'</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    call disk_load</pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    mov <span class="token register variable">dx</span>, <span class="token operator">[</span><span class="token number">0x8000</span><span class="token operator">]</span> <span class="token comment">; retrieve the first loaded word, 0xdada</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    call print_nl</pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    mov <span class="token register variable">dx</span>, <span class="token operator">[</span><span class="token number">0x8000</span> <span class="token operator">+</span> <span class="token number">512</span><span class="token operator">]</span> <span class="token comment">; first word from second loaded sector, 0xface</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    call print_hex</pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    jmp <span class="token operator">$</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token operator">%</span>include <span class="token string">"boot_print.asm"</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token operator">%</span>include <span class="token string">"boot_sect_disk.asm"</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">; Magic number</span></pre></td></tr><tr><td data-num="25"></td><td><pre>times <span class="token number">510</span> <span class="token operator">-</span> (<span class="token operator">$</span><span class="token operator">-</span><span class="token operator">$</span><span class="token operator">$</span>) db <span class="token number">0</span></pre></td></tr><tr><td data-num="26"></td><td><pre>dw <span class="token number">0xaa55</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token comment">; boot sector = sector 1 of cyl 0 of head 0 of hdd 0</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment">; from now on = sector 2 ...</span></pre></td></tr><tr><td data-num="30"></td><td><pre>times <span class="token number">256</span> dw <span class="token number">0xdada</span> <span class="token comment">; sector 2 = 512 bytes</span></pre></td></tr><tr><td data-num="31"></td><td><pre>times <span class="token number">256</span> dw <span class="token number">0xface</span> <span class="token comment">; sector 3 = 512 bytes</span></pre></td></tr></table></figure></div></details><p>🎉以上就是本章的全部内容，下一章将会继续讲解 <code>loader</code> 的实现～</p><br><div class="tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 操作系统</a> <a href="/tags/%E7%B3%BB%E5%88%97%E9%95%BF%E7%AF%87/" rel="tag"><i class="ic i-tag"></i> 系列长篇</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8A%9F/" rel="tag"><i class="ic i-tag"></i> 二进制基本功</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-09-21 20:00:03" itemprop="dateModified" datetime="2023-09-21T20:00:03+08:00">2023-09-21</time> </span><span id="os/02-mbr/" class="item leancloud_visitors" data-flag-title="02 - 从 BIOS 启动到 MBR 编写" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/wechatpay.png" alt="Gality 微信支付"><p>微信支付</p></div><div><img data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/alipay.png" alt="Gality 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Gality <i class="ic i-at"><em>@</em></i>藏器于身</li><li class="link"><strong>本文链接：</strong> <a href="https://gality.cn/os/02-mbr/" title="02 - 从 BIOS 启动到 MBR 编写">https://gality.cn/os/02-mbr/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/os/01-environment/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;imgcdn.gality.cn&#x2F;blog&#x2F;hlzx1w.png" title="01-环境准备"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 从 0 到 1</span><h3>01-环境准备</h3></a></div><div class="item right"><a href="/os/03-loader/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;imgcdn.gality.cn&#x2F;blog&#x2F;brqjlt.jpg" title="03-Loader编写之进入保护模式"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 从 0 到 1</span><h3>03-Loader编写之进入保护模式</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#bios%E5%92%8Cboot"><span class="toc-number">1.</span> <span class="toc-text">BIOS 和 BOOT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mbr%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">MBR 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%80%9A%E7%94%B5%E5%BC%80%E5%A7%8B"><span class="toc-number">2.1.</span> <span class="toc-text">从通电开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bios%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">BIOS 的工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mbr%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">mbr 的工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%88%80%E5%B0%8F%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">牛刀小试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#problem-time"><span class="toc-number">2.4.1.</span> <span class="toc-text">Problem Time</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">2.5.</span> <span class="toc-text">更进一步 (打印信息)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%96%B0%E8%A1%8C"><span class="toc-number">2.5.1.</span> <span class="toc-text">打印新行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.2.</span> <span class="toc-text">打印字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97"><span class="toc-number">2.5.3.</span> <span class="toc-text">以十六进制打印数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%AD%A5%E7%99%BB%E5%A4%A9"><span class="toc-number">2.6.</span> <span class="toc-text">一步登天</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nasm%E8%AF%BB%E7%A1%AC%E7%9B%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">nasm 读硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%80%BC%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">参数值讲解</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/os/00-preface/" rel="bookmark" title="序言-操作系统从0到1">序言-操作系统从0到1</a></li><li><a href="/os/01-environment/" rel="bookmark" title="01-环境准备">01-环境准备</a></li><li class="active"><a href="/os/02-mbr/" rel="bookmark" title="02-从BIOS启动到MBR编写">02-从BIOS启动到MBR编写</a></li><li><a href="/os/03-loader/" rel="bookmark" title="03-Loader编写之进入保护模式">03-Loader编写之进入保护模式</a></li><li><a href="/os/04-32bit-print/" rel="bookmark" title="04-在保护模式下打印">04-在保护模式下打印</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Gality" data-src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/images/avatar.png"><p class="name" itemprop="name">Gality</p><div class="description" itemprop="description">安全杂记 & 日常随感</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">36</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">20</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">54</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dhbGl0eTM2OQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Gality369"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <a href="https://gality.cn/about/" title="https:&#x2F;&#x2F;gality.cn&#x2F;about&#x2F;" class="item about"><i class="ic i-address-card"></i></a> <span class="exturl item email" data-url="bWFpbHRvOjQzNDQwMDcyNkBxcS5jb20=" title="mailto:434400726@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>小伙伴</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>资源</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/os/01-environment/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/os/03-loader/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/conda-mamba/" title="机器学习-环境搭建踩坑-conda&amp;mamba">机器学习-环境搭建踩坑-conda&mamba</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ml/" title="分类于 机器学习">机器学习</a> <i class="ic i-angle-right"></i> <a href="/categories/ml/homework/" title="分类于 作业">作业</a></div><span><a href="/ml/homework/HW-1/" title="李宏毅ML2022-Spring大作业01｜COVID-19 Cases Prediction (Regression)">李宏毅ML2022-Spring大作业01｜COVID-19 Cases Prediction (Regression)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/0-1/" title="分类于 从 0 到 1">从 0 到 1</a></div><span><a href="/os/03-loader/" title="03-Loader编写之进入保护模式">03-Loader编写之进入保护模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ponder/" title="分类于 思考与沉淀">思考与沉淀</a></div><span><a href="/ponder/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/" title="科技协会面试反思与总结">科技协会面试反思与总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/RTX4080-tensorflow2/" title="在 RTX 4080 上运行 tensorflow 2">在 RTX 4080 上运行 tensorflow 2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/blog%E6%90%AD%E5%BB%BA/" title="blog搭建&amp;Hello world">blog搭建&Hello world</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/misc/" title="分类于 杂项">杂项</a> <i class="ic i-angle-right"></i> <a href="/categories/misc/trail-and-error/" title="分类于 踩坑">踩坑</a></div><span><a href="/misc/trail-and-error/include-error/" title="“C&#x2F;C++找不到头文件”解决方案大全">“C/C++找不到头文件”解决方案大全</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/os/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/os/0-1/" title="分类于 从 0 到 1">从 0 到 1</a></div><span><a href="/os/04-32bit-print/" title="04-在保护模式下打印">04-在保护模式下打印</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ml/" title="分类于 机器学习">机器学习</a></div><span><a href="/ml/CNN/" title="CNN ｜ Network Architecture Designed for Image">CNN ｜ Network Architecture Designed for Image</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/llvm/" title="分类于 LLVM">LLVM</a></div><span><a href="/llvm/llvm-tutorial/" title="LLVM 简明教程">LLVM 简明教程</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Gality @ Samadhi</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">253k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">7:40</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"os/02-mbr/",favicon:{show:"（●´3｀●）哎呀呀～",hide:"(´Д｀)吓死你"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/gality369/gality369.github.io@latest/js/app.js?v=0.2.5"></script></body></html>